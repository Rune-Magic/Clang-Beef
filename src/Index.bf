/* Auto generated by https://github.com/Rune-Magic/C2Beef-Binding-Generator
 * DO NOT EDIT
 */

using System;
using System.Interop;

namespace LibClang;

static
{
	public const c_int CINDEX_VERSION_MAJOR = 0;
	public const c_int CINDEX_VERSION_MINOR = 64;
}

/** An "index" that consists of a set of translation units that would
 *  typically be linked together into an executable or library.
 */
class CXIndex { private this() {} }

/** An opaque type representing target information for a given translation
 *  unit.
 */
class CXTargetInfo { private this() {} }

/** A single translation unit, which resides in an index.
 */
class CXTranslationUnit { private this() {} }

/** Opaque pointer representing client data that will be passed through
 *  to various callbacks and visitors.
 */
typealias CXClientData = void*;

/** Provides the contents of a file that has not yet been saved to disk.
 *  Each CXUnsavedFile instance provides the name of a file on the
 *  system along with the current contents of that file that have not
 *  yet been saved to disk.
 */
[CRepr] struct CXUnsavedFile
{
	/** The file whose contents have not yet been saved.
	 *  This file must already exist in the file system.
	 */
	public c_char* Filename;

	/** A buffer containing the unsaved contents of this file.
	 */
	public c_char* Contents;

	/** The length of the unsaved contents of this buffer.
	 */
	public c_ulong Length;
}

/** Describes the availability of a particular entity, which indicates
 *  whether the use of this entity will result in a warning or error due to
 *  it being deprecated or unavailable.
 */
[CRepr, AllowDuplicates] enum CXAvailabilityKind : c_int
{
	/** The entity is available.
	 */
	Available = 0,

	/** The entity is available, but has been deprecated (and its use is
	 *  not recommended).
	 */
	Deprecated = 1,

	/** The entity is not available; any use of it will be an error.
	 */
	NotAvailable = 2,

	/** The entity is available, but not accessible; any use of it will be
	 *  an error.
	 */
	NotAccessible = 3,
}

/** Describes a version number of the form major.minor.subminor.
 */
[CRepr] struct CXVersion
{
	/** The major version number, e.g., the '10' in '10.7.3'. A negative
	 *  value indicates that there is no version number at all.
	 */
	public c_int Major;

	/** The minor version number, e.g., the '7' in '10.7.3'. This value
	 *  will be negative if no minor version number was provided, e.g., for
	 *  version '10'.
	 */
	public c_int Minor;

	/** The subminor version number, e.g., the '3' in '10.7.3'. This value
	 *  will be negative if no minor or subminor version number was provided,
	 *  e.g., in version '10' or '10.7'.
	 */
	public c_int Subminor;
}

/** Describes the exception specification of a cursor.
 *  A negative value indicates that the cursor is not a function declaration.
 */
[CRepr, AllowDuplicates] enum CXCursor_ExceptionSpecificationKind : c_int
{
	/** The cursor has no exception specification.
	 */
	None = 0,

	/** The cursor has exception specification throw()
	 */
	DynamicNone = 1,

	/** The cursor has exception specification throw(T1, T2)
	 */
	Dynamic = 2,

	/** The cursor has exception specification throw(...).
	 */
	MSAny = 3,

	/** The cursor has exception specification basic noexcept.
	 */
	BasicNoexcept = 4,

	/** The cursor has exception specification computed noexcept.
	 */
	ComputedNoexcept = 5,

	/** The exception specification has not yet been evaluated.
	 */
	Unevaluated = 6,

	/** The exception specification has not yet been instantiated.
	 */
	Uninstantiated = 7,

	/** The exception specification has not been parsed yet.
	 */
	Unparsed = 8,

	/** The cursor has a __declspec(nothrow) exception specification.
	 */
	NoThrow = 9,
}

extension Clang
{
	/** Provides a shared context for creating translation units.
	 *  It provides two options:
	 *  - excludeDeclarationsFromPCH: When non-zero, allows enumeration of "local"
	 *  declarations (when loading any new translation units). A "local" declaration
	 *  is one that belongs in the translation unit itself and not in a precompiled
	 *  header that was used by the translation unit. If zero, all declarations
	 *  will be enumerated.
	 *  Here is an example:
	 *  
	 *  ```
	 *  // excludeDeclsFromPCH = 1, displayDiagnostics=1
	 *  Idx = clang_createIndex(1, 1);
	 *  
	 *  // IndexTest.pch was produced with the following command:
	 *  // "clang -x c IndexTest.h -emit-ast -o IndexTest.pch"
	 *  TU = clang_createTranslationUnit(Idx, "IndexTest.pch");
	 *  
	 *  // This will load all the symbols from 'IndexTest.pch'
	 *  clang_visitChildren(clang_getTranslationUnitCursor(TU),
	 *                      TranslationUnitVisitor, 0);
	 *  clang_disposeTranslationUnit(TU);
	 *  
	 *  // This will load all the symbols from 'IndexTest.c', excluding symbols
	 *  // from 'IndexTest.pch'.
	 *  char *args[] = { "-Xclang", "-include-pch=IndexTest.pch" };
	 *  TU = clang_createTranslationUnitFromSourceFile(Idx, "IndexTest.c", 2, args,
	 *                                                 0, 0);
	 *  clang_visitChildren(clang_getTranslationUnitCursor(TU),
	 *                      TranslationUnitVisitor, 0);
	 *  clang_disposeTranslationUnit(TU);
	 *  ```
	 *  This process of creating the 'pch', loading it separately, and using it (via
	 *  -include-pch) allows 'excludeDeclsFromPCH' to remove redundant callbacks
	 *  (which gives the indexer the same performance benefit as the compiler).
	 */
	[Import(Clang.dll), LinkName("clang_createIndex")] public static extern CXIndex CreateIndex(c_int excludeDeclarationsFromPCH, c_int displayDiagnostics);

	/** Destroy the given index.
	 *  The index must not be destroyed until all of the translation units created
	 *  within that index have been destroyed.
	 */
	[Import(Clang.dll), LinkName("clang_disposeIndex")] public static extern void DisposeIndex(CXIndex index);
}

[CRepr, AllowDuplicates] enum CXChoice : c_int
{
	/** Use the default value of an option that may depend on the process
	 *  environment.
	 */
	Default = 0,

	/** Enable the option.
	 */
	Enabled = 1,

	/** Disable the option.
	 */
	Disabled = 2,
}

[CRepr, AllowDuplicates] enum CXGlobalOptFlags : c_int
{
	/** Used to indicate that no special CXIndex options are needed.
	 */
	None = 0x0,

	/** Used to indicate that threads that libclang creates for indexing
	 *  purposes should use background priority.
	 *  Affects #clang_indexSourceFile, #clang_indexTranslationUnit,
	 *  #clang_parseTranslationUnit, #clang_saveTranslationUnit.
	 */
	ThreadBackgroundPriorityForIndexing = 0x1,

	/** Used to indicate that threads that libclang creates for editing
	 *  purposes should use background priority.
	 *  Affects #clang_reparseTranslationUnit, #clang_codeCompleteAt,
	 *  #clang_annotateTokens
	 */
	ThreadBackgroundPriorityForEditing = 0x2,

	/** Used to indicate that all threads that libclang creates should use
	 *  background priority.
	 */
	ThreadBackgroundPriorityForAll = ThreadBackgroundPriorityForIndexing | ThreadBackgroundPriorityForEditing,
}

/** Index initialization options.
 *  0 is the default value of each member of this struct except for Size.
 *  Initialize the struct in one of the following three ways to avoid adapting
 *  code each time a new member is added to it:
 *  
 *  ```
 *  CXIndexOptions Opts;
 *  memset(&Opts, 0, sizeof(Opts));
 *  Opts.Size = sizeof(CXIndexOptions);
 *  ```
 *  or explicitly initialize the first data member and zero-initialize the rest:
 *  
 *  ```
 *  CXIndexOptions Opts = { sizeof(CXIndexOptions) };
 *  ```
 *  or to prevent the -Wmissing-field-initializers warning for the above version:
 *  
 *  ```
 *  CXIndexOptions Opts{};
 *  Opts.Size = sizeof(CXIndexOptions);
 *  ```
 *  
 */
[CRepr] struct CXIndexOptions
{
	/** The size of struct CXIndexOptions used for option versioning.
	 *  Always initialize this member to sizeof(CXIndexOptions), or assign
	 *  sizeof(CXIndexOptions) to it right after creating a CXIndexOptions object.
	 */
	public c_uint Size;

	/** A CXChoice enumerator that specifies the indexing priority policy.
	 *  
	 *  @sa CXGlobalOpt_ThreadBackgroundPriorityForIndexing
	 */
	public c_uchar ThreadBackgroundPriorityForIndexing;

	/** A CXChoice enumerator that specifies the editing priority policy.
	 *  
	 *  @sa CXGlobalOpt_ThreadBackgroundPriorityForEditing
	 */
	public c_uchar ThreadBackgroundPriorityForEditing;

	/** 
	 *  @see clang_createIndex()
	 */
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 0), "ExcludeDeclarationsFromPCH")]

	/** 
	 *  @see clang_createIndex()
	 */
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 1), "DisplayDiagnostics")]

	/** Store PCH in memory. If zero, PCH are stored in temporary files.
	 */
	[Bitfield(.Public, .BitsAt(bits: 1, pos: 2), "StorePreamblesInMemory")]

	private uint32 __bitfield_12777;

	/** The path to a directory, in which to store temporary PCH files. If null or
	 *  empty, the default system temporary directory is used. These PCH files are
	 *  deleted on clean exit but stay on disk if the program crashes or is killed.
	 *  This option is ignored if @a StorePreamblesInMemory is non-zero. 
	 *  Libclang does not create the directory at the specified path in the file
	 *  system. Therefore it must exist, or storing PCH files will fail.
	 */
	public c_char* PreambleStoragePath;

	/** Specifies a path which will contain log files for certain libclang
	 *  invocations. A null value implies that libclang invocations are not logged.
	 */
	public c_char* InvocationEmissionPath;
}

extension Clang
{
	/** Provides a shared context for creating translation units.
	 *  Call this function instead of clang_createIndex() if you need to configure
	 *  the additional options in CXIndexOptions.
	 *  
	 *  @returns The created index or null in case of error, such as an unsupported
	 *  value of options->Size.
	 *  For example:
	 *  
	 *  ```
	 *  CXIndex createIndex(const char *ApplicationTemporaryPath) {
	 *  const int ExcludeDeclarationsFromPCH = 1;
	 *  const int DisplayDiagnostics = 1;
	 *  CXIndex Idx;
	 *  #if CINDEX_VERSION_MINOR >= 64
	 *  CXIndexOptions Opts;
	 *  memset(&Opts, 0, sizeof(Opts));
	 *  Opts.Size = sizeof(CXIndexOptions);
	 *  Opts.ThreadBackgroundPriorityForIndexing = 1;
	 *  Opts.ExcludeDeclarationsFromPCH = ExcludeDeclarationsFromPCH;
	 *  Opts.DisplayDiagnostics = DisplayDiagnostics;
	 *  Opts.PreambleStoragePath = ApplicationTemporaryPath;
	 *  Idx = clang_createIndexWithOptions(&Opts);
	 *  if (Idx)
	 *    return Idx;
	 *  fprintf(stderr,
	 *          "clang_createIndexWithOptions() failed. "
	 *          "CINDEX_VERSION_MINOR = %d, sizeof(CXIndexOptions) = %u\n",
	 *          CINDEX_VERSION_MINOR, Opts.Size);
	 *  #else
	 *  (void)ApplicationTemporaryPath;
	 *  #endif
	 *  Idx = clang_createIndex(ExcludeDeclarationsFromPCH, DisplayDiagnostics);
	 *  clang_CXIndex_setGlobalOptions(
	 *      Idx, clang_CXIndex_getGlobalOptions(Idx) |
	 *               CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
	 *  return Idx;
	 *  }
	 *  ```
	 *  
	 *  @sa clang_createIndex()
	 */
	[Import(Clang.dll), LinkName("clang_createIndexWithOptions")] public static extern CXIndex CreateIndexWithOptions(CXIndexOptions* options);

	/** Sets general options associated with a CXIndex.
	 *  This function is DEPRECATED. Set
	 *  CXIndexOptions::ThreadBackgroundPriorityForIndexing and/or
	 *  CXIndexOptions::ThreadBackgroundPriorityForEditing and call
	 *  clang_createIndexWithOptions() instead.
	 *  For example:
	 *  
	 *  ```
	 *  CXIndex idx = ...;
	 *  clang_CXIndex_setGlobalOptions(idx,
	 *    clang_CXIndex_getGlobalOptions(idx) |
	 *    CXGlobalOpt_ThreadBackgroundPriorityForIndexing);
	 *  ```
	 *  
	 *  @param options A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags.
	 */
	[Import(Clang.dll), LinkName("clang_CXIndex_setGlobalOptions")] public static extern void CXIndex_SetGlobalOptions(CXIndex, c_uint options);

	/** Gets the general options associated with a CXIndex.
	 *  This function allows to obtain the final option values used by libclang after
	 *  specifying the option policies via CXChoice enumerators.
	 *  
	 *  @returns A bitmask of options, a bitwise OR of CXGlobalOpt_XXX flags that
	 *  are associated with the given CXIndex object.
	 */
	[Import(Clang.dll), LinkName("clang_CXIndex_getGlobalOptions")] public static extern c_uint CXIndex_GetGlobalOptions(CXIndex);

	/** Sets the invocation emission path option in a CXIndex.
	 *  This function is DEPRECATED. Set CXIndexOptions::InvocationEmissionPath and
	 *  call clang_createIndexWithOptions() instead.
	 *  The invocation emission path specifies a path which will contain log
	 *  files for certain libclang invocations. A null value (default) implies that
	 *  libclang invocations are not logged..
	 */
	[Import(Clang.dll), LinkName("clang_CXIndex_setInvocationEmissionPathOption")] public static extern void CXIndex_SetInvocationEmissionPathOption(CXIndex, c_char* Path);

	/** Determine whether the given header is guarded against
	 *  multiple inclusions, either with the conventional
	 *  
	 *  #
	 *  ifndef/
	 *  #
	 *  define/
	 *  #
	 *  endif macro guards or with 
	 *  #
	 *  pragma once.
	 */
	[Import(Clang.dll), LinkName("clang_isFileMultipleIncludeGuarded")] public static extern c_uint IsFileMultipleIncludeGuarded(CXTranslationUnit tu, CXFile file);

	/** Retrieve a file handle within the given translation unit.
	 *  
	 *  @param tu the translation unit
	 *  
	 *  @param file_name the name of the file.
	 *  
	 *  @returns the file handle for the named file in the translation unit @p tu, or a NULL file handle if the file was not a part of this translation unit. 
	 */
	[Import(Clang.dll), LinkName("clang_getFile")] public static extern CXFile GetFile(CXTranslationUnit tu, c_char* file_name);

	/** Retrieve the buffer associated with the given file.
	 *  
	 *  @param tu the translation unit
	 *  
	 *  @param file the file for which to retrieve the buffer.
	 *  
	 *  @param size [out] if non-NULL, will be set to the size of the buffer.
	 *  
	 *  @returns a pointer to the buffer in memory that holds the contents of
	 *  @p file, or a NULL pointer when the file is not loaded. 
	 */
	[Import(Clang.dll), LinkName("clang_getFileContents")] public static extern c_char* GetFileContents(CXTranslationUnit tu, CXFile file, out c_size size);

	/** Retrieves the source location associated with a given file/line/column
	 *  in a particular translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getLocation")] public static extern CXSourceLocation GetLocation(CXTranslationUnit tu, CXFile file, c_uint line, c_uint column);

	/** Retrieves the source location associated with a given character offset
	 *  in a particular translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getLocationForOffset")] public static extern CXSourceLocation GetLocationForOffset(CXTranslationUnit tu, CXFile file, c_uint offset);

	/** Retrieve all ranges that were skipped by the preprocessor.
	 *  The preprocessor will skip lines when they are surrounded by an
	 *  if/ifdef/ifndef directive whose condition does not evaluate to true.
	 */
	[Import(Clang.dll), LinkName("clang_getSkippedRanges")] public static extern CXSourceRangeList* GetSkippedRanges(CXTranslationUnit tu, CXFile file);

	/** Retrieve all ranges from all files that were skipped by the
	 *  preprocessor.
	 *  The preprocessor will skip lines when they are surrounded by an
	 *  if/ifdef/ifndef directive whose condition does not evaluate to true.
	 */
	[Import(Clang.dll), LinkName("clang_getAllSkippedRanges")] public static extern CXSourceRangeList* GetAllSkippedRanges(CXTranslationUnit tu);

	/** Determine the number of diagnostics produced for the given
	 *  translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getNumDiagnostics")] public static extern c_uint GetNumDiagnostics(CXTranslationUnit Unit);

	/** Retrieve a diagnostic associated with the given translation unit.
	 *  
	 *  @param Unit the translation unit to query.
	 *  
	 *  @param Index the zero-based diagnostic number to retrieve.
	 *  
	 *  @returns the requested diagnostic. This diagnostic must be freed
	 *  via a call to @c clang_disposeDiagnostic().  
	 */
	[Import(Clang.dll), LinkName("clang_getDiagnostic")] public static extern CXDiagnostic GetDiagnostic(CXTranslationUnit Unit, c_uint Index);

	/** Retrieve the complete set of diagnostics associated with a
	 *  translation unit.
	 *  
	 *  @param Unit the translation unit to query.
	 */
	[Import(Clang.dll), LinkName("clang_getDiagnosticSetFromTU")] public static extern CXDiagnosticSet GetDiagnosticSetFromTU(CXTranslationUnit Unit);

	/** Get the original translation unit source file name.
	 */
	[Import(Clang.dll), LinkName("clang_getTranslationUnitSpelling")] public static extern CXString GetTranslationUnitSpelling(CXTranslationUnit CTUnit);

	/** Return the CXTranslationUnit for a given source file and the provided
	 *  command line arguments one would pass to the compiler.
	 *  Note: The 'source_filename' argument is optional.  If the caller provides a
	 *  NULL pointer, the name of the source file is expected to reside in the
	 *  specified command line arguments.
	 *  Note: When encountered in 'clang_command_line_args', the following options
	 *  are ignored:
	 *  '-c'
	 *  '-emit-ast'
	 *  '-fsyntax-only'
	 *  '-o 
	 *  <
	 *  output file>'  (both '-o' and '
	 *  <
	 *  output file>' are ignored)
	 *  
	 *  @param CIdx The index object with which the translation unit will be
	 *  associated.
	 *  
	 *  @param source_filename The name of the source file to load, or NULL if the
	 *  source file is included in @p clang_command_line_args. 
	 *   
	 *  @param num_clang_command_line_args The number of command-line arguments in
	 *  @p clang_command_line_args. 
	 *   
	 *  @param clang_command_line_args The command-line arguments that would be
	 *  passed to the @c clang executable if it were being invoked out-of-process. These command-line options will be parsed and will affect how the translation
	 *  unit is parsed. Note that the following options are ignored: '-c',
	 *  '-emit-ast', '-fsyntax-only' (which is the default), and '-o 
	 *  <
	 *  output file>'.
	 *  
	 *  @param num_unsaved_files the number of unsaved file entries in @p unsaved_files. 
	 *   
	 *  @param unsaved_files the files that have not yet been saved to disk
	 *  but may be required for code completion, including the contents of
	 *  those files.  The contents and name of these files (as specified by
	 *  CXUnsavedFile) are copied when necessary, so the client only needs to
	 *  guarantee their validity until the call to this function returns.
	 */
	[Import(Clang.dll), LinkName("clang_createTranslationUnitFromSourceFile")] public static extern CXTranslationUnit CreateTranslationUnitFromSourceFile(CXIndex CIdx, c_char* source_filename, c_int num_clang_command_line_args, c_char** Command_Line_Args, c_uint num_unsaved_files, CXUnsavedFile* unsaved_files);

	/** Same as @c clang_createTranslationUnit2, but returns the @c CXTranslationUnit instead of an error code.  In case of an error this routine returns a @c NULL  @c CXTranslationUnit, without further detailed error codes.
	 */
	[Import(Clang.dll), LinkName("clang_createTranslationUnit")] public static extern CXTranslationUnit CreateTranslationUnit(CXIndex CIdx, c_char* ast_filename);

	/** Create a translation unit from an AST file (@c -emit-ast). 
	 *   
	 *  @param out_TU A non-NULL pointer to store the created
	 *  @c CXTranslationUnit. 
	 *   
	 *  @returns Zero on success, otherwise returns an error code.
	 */
	[Import(Clang.dll), LinkName("clang_createTranslationUnit2")] public static extern CXErrorCode CreateTranslationUnit2(CXIndex CIdx, c_char* ast_filename, out CXTranslationUnit out_TU);
}

/** Flags that control the creation of translation units.
 *  The enumerators in this enumeration type are meant to be bitwise
 *  ORed together to specify which options should be used when
 *  constructing the translation unit.
 */
[CRepr, AllowDuplicates] enum CXTranslationUnit_Flags : c_int
{
	/** Used to indicate that no special translation-unit options are
	 *  needed.
	 */
	None = 0x0,

	/** Used to indicate that the parser should construct a "detailed"
	 *  preprocessing record, including all macro definitions and instantiations.
	 *  Constructing a detailed preprocessing record requires more memory
	 *  and time to parse, since the information contained in the record
	 *  is usually not retained. However, it can be useful for
	 *  applications that require more detailed information about the
	 *  behavior of the preprocessor.
	 */
	DetailedPreprocessingRecord = 0x01,

	/** Used to indicate that the translation unit is incomplete.
	 *  When a translation unit is considered "incomplete", semantic
	 *  analysis that is typically performed at the end of the
	 *  translation unit will be suppressed. For example, this suppresses
	 *  the completion of tentative declarations in C and of
	 *  instantiation of implicitly-instantiation function templates in
	 *  C++. This option is typically used when parsing a header with the
	 *  intent of producing a precompiled header.
	 */
	Incomplete = 0x02,

	/** Used to indicate that the translation unit should be built with an
	 *  implicit precompiled header for the preamble.
	 *  An implicit precompiled header is used as an optimization when a
	 *  particular translation unit is likely to be reparsed many times
	 *  when the sources aren't changing that often. In this case, an
	 *  implicit precompiled header will be built containing all of the
	 *  initial includes at the top of the main file (what we refer to as
	 *  the "preamble" of the file). In subsequent parses, if the
	 *  preamble or the files in it have not changed, @c clang_reparseTranslationUnit() will re-use the implicit precompiled header to improve parsing performance.
	 */
	PrecompiledPreamble = 0x04,

	/** Used to indicate that the translation unit should cache some
	 *  code-completion results with each reparse of the source file.
	 *  Caching of code-completion results is a performance optimization that
	 *  introduces some overhead to reparsing but improves the performance of
	 *  code-completion operations.
	 */
	CacheCompletionResults = 0x08,

	/** Used to indicate that the translation unit will be serialized with
	 *  @c clang_saveTranslationUnit. 
	 *  This option is typically used when parsing a header with the intent of producing a precompiled header.
	 */
	orSerialization = 0x10,

	/** DEPRECATED: Enabled chained precompiled preambles in C++.
	 *  Note: this is a *temporary* option that is available only while
	 *  we are testing C++ precompiled preamble support. It is deprecated.
	 */
	CXXChainedPCH = 0x20,

	/** Used to indicate that function/method bodies should be skipped while
	 *  parsing.
	 *  This option can be used to search for declarations/definitions while
	 *  ignoring the usages.
	 */
	SkipFunctionBodies = 0x40,

	/** Used to indicate that brief documentation comments should be
	 *  included into the set of code completions returned from this translation
	 *  unit.
	 */
	IncludeBriefCommentsInCodeCompletion = 0x80,

	/** Used to indicate that the precompiled preamble should be created on
	 *  the first parse. Otherwise it will be created on the first reparse. This
	 *  trades runtime on the first parse (serializing the preamble takes time) for
	 *  reduced runtime on the second parse (can now reuse the preamble).
	 */
	CreatePreambleOnFirstParse = 0x100,

	/** Do not stop processing when fatal errors are encountered.
	 *  When fatal errors are encountered while parsing a translation unit,
	 *  semantic analysis is typically stopped early when compiling code. A common
	 *  source for fatal errors are unresolvable include files. For the
	 *  purposes of an IDE, this is undesirable behavior and as much information
	 *  as possible should be reported. Use this flag to enable this behavior.
	 */
	KeepGoing = 0x200,

	/** Sets the preprocessor in a mode for parsing a single file only.
	 */
	SingleFileParse = 0x400,

	/** Used in combination with CXTranslationUnit_SkipFunctionBodies to
	 *  constrain the skipping of function bodies to the preamble.
	 *  The function bodies of the main file are not skipped.
	 */
	LimitSkipFunctionBodiesToPreamble = 0x800,

	/** Used to indicate that attributed types should be included in CXType.
	 */
	IncludeAttributedTypes = 0x1000,

	/** Used to indicate that implicit attributes should be visited.
	 */
	VisitImplicitAttributes = 0x2000,

	/** Used to indicate that non-errors from included files should be ignored.
	 *  If set, clang_getDiagnosticSetFromTU() will not report e.g. warnings from
	 *  included files anymore. This speeds up clang_getDiagnosticSetFromTU() for
	 *  the case where these warnings are not of interest, as for an IDE for
	 *  example, which typically shows only the diagnostics in the main file.
	 */
	IgnoreNonErrorsFromIncludedFiles = 0x4000,

	/** Tells the preprocessor not to skip excluded conditional blocks.
	 */
	RetainExcludedConditionalBlocks = 0x8000,
}

extension Clang
{
	/** Returns the set of flags that is suitable for parsing a translation
	 *  unit that is being edited.
	 *  The set of flags returned provide options for @c clang_parseTranslationUnit() to indicate that the translation unit is likely to be reparsed many times, either explicitly (via @c clang_reparseTranslationUnit()) or implicitly (e.g., by code completion (@c clang_codeCompletionAt())). The returned flag set contains an unspecified set of optimizations (e.g., the precompiled
	 *  preamble) geared toward improving the performance of these routines. The
	 *  set of optimizations enabled may change from one version to the next.
	 */
	[Import(Clang.dll), LinkName("clang_defaultEditingTranslationUnitOptions")] public static extern c_uint DefaultEditingTranslationUnitOptions();

	/** Same as @c clang_parseTranslationUnit2, but returns the @c CXTranslationUnit instead of an error code.  In case of an error this routine returns a @c NULL  @c CXTranslationUnit, without further detailed error codes.
	 */
	[Import(Clang.dll), LinkName("clang_parseTranslationUnit")] public static extern CXTranslationUnit ParseTranslationUnit(CXIndex CIdx, c_char* source_filename, c_char** command_line_args, c_int num_command_line_args, CXUnsavedFile* unsaved_files, c_uint num_unsaved_files, c_uint options);

	/** Parse the given source file and the translation unit corresponding
	 *  to that file.
	 *  This routine is the main entry point for the Clang C API, providing the
	 *  ability to parse a source file into a translation unit that can then be
	 *  queried by other functions in the API. This routine accepts a set of
	 *  command-line arguments so that the compilation can be configured in the same
	 *  way that the compiler is configured on the command line.
	 *  
	 *  @param CIdx The index object with which the translation unit will be
	 *  associated.
	 *  
	 *  @param source_filename The name of the source file to load, or NULL if the
	 *  source file is included in @c command_line_args. 
	 *   
	 *  @param command_line_args The command-line arguments that would be
	 *  passed to the @c clang executable if it were being invoked out-of-process. These command-line options will be parsed and will affect how the translation
	 *  unit is parsed. Note that the following options are ignored: '-c',
	 *  '-emit-ast', '-fsyntax-only' (which is the default), and '-o 
	 *  <
	 *  output file>'.
	 *  
	 *  @param num_command_line_args The number of command-line arguments in
	 *  @c command_line_args. 
	 *   
	 *  @param unsaved_files the files that have not yet been saved to disk
	 *  but may be required for parsing, including the contents of
	 *  those files.  The contents and name of these files (as specified by
	 *  CXUnsavedFile) are copied when necessary, so the client only needs to
	 *  guarantee their validity until the call to this function returns.
	 *  
	 *  @param num_unsaved_files the number of unsaved file entries in @p unsaved_files. 
	 *   
	 *  @param options A bitmask of options that affects how the translation unit
	 *  is managed but not its compilation. This should be a bitwise OR of the
	 *  CXTranslationUnit_XXX flags.
	 *  
	 *  @param out_TU A non-NULL pointer to store the created
	 *  @c CXTranslationUnit, describing the parsed code and containing any diagnostics produced by the compiler.
	 *  
	 *  @returns Zero on success, otherwise returns an error code.
	 */
	[Import(Clang.dll), LinkName("clang_parseTranslationUnit2")] public static extern CXErrorCode ParseTranslationUnit2(CXIndex CIdx, c_char* source_filename, c_char** command_line_args, c_int num_command_line_args, CXUnsavedFile* unsaved_files, c_uint num_unsaved_files, c_uint options, out CXTranslationUnit out_TU);

	/** Same as clang_parseTranslationUnit2 but requires a full command line
	 *  for @c command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
	 */
	[Import(Clang.dll), LinkName("clang_parseTranslationUnit2FullArgv")] public static extern CXErrorCode ParseTranslationUnit2FullArgv(CXIndex CIdx, c_char* source_filename, c_char** command_line_args, c_int num_command_line_args, CXUnsavedFile* unsaved_files, c_uint num_unsaved_files, c_uint options, CXTranslationUnit* out_TU);
}

/** Flags that control how translation units are saved.
 *  The enumerators in this enumeration type are meant to be bitwise
 *  ORed together to specify which options should be used when
 *  saving the translation unit.
 */
[CRepr, AllowDuplicates] enum CXSaveTranslationUnit_Flags : c_int
{
	/** Used to indicate that no special saving options are needed.
	 */
	None = 0x0,
}

extension Clang
{
	/** Returns the set of flags that is suitable for saving a translation
	 *  unit.
	 *  The set of flags returned provide options for
	 *  @c clang_saveTranslationUnit() by default. The returned flag set contains an unspecified set of options that save translation units with
	 *  the most commonly-requested data.
	 */
	[Import(Clang.dll), LinkName("clang_defaultSaveOptions")] public static extern c_uint DefaultSaveOptions(CXTranslationUnit TU);
}

/** Describes the kind of error that occurred (if any) in a call to
 *  @c clang_saveTranslationUnit().  
 */
[CRepr, AllowDuplicates] enum CXSaveError : c_int
{
	/** Indicates that no error occurred while saving a translation unit.
	 */
	None = 0,

	/** Indicates that an unknown error occurred while attempting to save
	 *  the file.
	 *  This error typically indicates that file I/O failed when attempting to
	 *  write the file.
	 */
	Unknown = 1,

	/** Indicates that errors during translation prevented this attempt
	 *  to save the translation unit.
	 *  Errors that prevent the translation unit from being saved can be
	 *  extracted using @c clang_getNumDiagnostics() and  @c clang_getDiagnostic().  
	 */
	TranslationErrors = 2,

	/** Indicates that the translation unit to be saved was somehow
	 *  invalid (e.g., NULL).
	 */
	InvalidTU = 3,
}

extension Clang
{
	/** Saves a translation unit into a serialized representation of
	 *  that translation unit on disk.
	 *  Any translation unit that was parsed without error can be saved
	 *  into a file. The translation unit can then be deserialized into a
	 *  new @c CXTranslationUnit with  @c clang_createTranslationUnit() or, if it is an incomplete translation unit that corresponds to a
	 *  header, used as a precompiled header when parsing other translation
	 *  units.
	 *  
	 *  @param TU The translation unit to save.
	 *  
	 *  @param FileName The file to which the translation unit will be saved.
	 *  
	 *  @param options A bitmask of options that affects how the translation unit
	 *  is saved. This should be a bitwise OR of the
	 *  CXSaveTranslationUnit_XXX flags.
	 *  
	 *  @returns A value that will match one of the enumerators of the CXSaveError
	 *  enumeration. Zero (CXSaveError_None) indicates that the translation unit was
	 *  saved successfully, while a non-zero value indicates that a problem occurred.
	 */
	[Import(Clang.dll), LinkName("clang_saveTranslationUnit")] public static extern c_int SaveTranslationUnit(CXTranslationUnit TU, c_char* FileName, c_uint options);

	/** Suspend a translation unit in order to free memory associated with it.
	 *  A suspended translation unit uses significantly less memory but on the other
	 *  side does not support any other calls than @c clang_reparseTranslationUnit to resume it or  @c clang_disposeTranslationUnit to dispose it completely. 
	 */
	[Import(Clang.dll), LinkName("clang_suspendTranslationUnit")] public static extern c_uint SuspendTranslationUnit(CXTranslationUnit);

	/** Destroy the specified CXTranslationUnit object.
	 */
	[Import(Clang.dll), LinkName("clang_disposeTranslationUnit")] public static extern void DisposeTranslationUnit(CXTranslationUnit);
}

/** Flags that control the reparsing of translation units.
 *  The enumerators in this enumeration type are meant to be bitwise
 *  ORed together to specify which options should be used when
 *  reparsing the translation unit.
 */
[CRepr, AllowDuplicates] enum CXReparse_Flags : c_int
{
	/** Used to indicate that no special reparsing options are needed.
	 */
	None = 0x0,
}

extension Clang
{
	/** Returns the set of flags that is suitable for reparsing a translation
	 *  unit.
	 *  The set of flags returned provide options for
	 *  @c clang_reparseTranslationUnit() by default. The returned flag set contains an unspecified set of optimizations geared toward common uses
	 *  of reparsing. The set of optimizations enabled may change from one version
	 *  to the next.
	 */
	[Import(Clang.dll), LinkName("clang_defaultReparseOptions")] public static extern c_uint DefaultReparseOptions(CXTranslationUnit TU);

	/** Reparse the source files that produced this translation unit.
	 *  This routine can be used to re-parse the source files that originally
	 *  created the given translation unit, for example because those source files
	 *  have changed (either on disk or as passed via @p unsaved_files). The source code will be reparsed with the same command-line options as it
	 *  was originally parsed.
	 *  Reparsing a translation unit invalidates all cursors and source locations
	 *  that refer into that translation unit. This makes reparsing a translation
	 *  unit semantically equivalent to destroying the translation unit and then
	 *  creating a new translation unit with the same command-line arguments.
	 *  However, it may be more efficient to reparse a translation
	 *  unit using this routine.
	 *  
	 *  @param TU The translation unit whose contents will be re-parsed. The
	 *  translation unit must originally have been built with
	 *  @c clang_createTranslationUnitFromSourceFile(). 
	 *   
	 *  @param num_unsaved_files The number of unsaved file entries in @p unsaved_files. 
	 *   
	 *  @param unsaved_files The files that have not yet been saved to disk
	 *  but may be required for parsing, including the contents of
	 *  those files.  The contents and name of these files (as specified by
	 *  CXUnsavedFile) are copied when necessary, so the client only needs to
	 *  guarantee their validity until the call to this function returns.
	 *  
	 *  @param options A bitset of options composed of the flags in CXReparse_Flags.
	 *  The function @c clang_defaultReparseOptions() produces a default set of options recommended for most uses, based on the translation unit.
	 *  
	 *  @returns 0 if the sources could be reparsed.  A non-zero error code will be
	 *  returned if reparsing was impossible, such that the translation unit is
	 *  invalid. In such cases, the only valid call for @c TU is @c clang_disposeTranslationUnit(TU). The error codes returned by this routine are described by the @c CXErrorCode enum. 
	 */
	[Import(Clang.dll), LinkName("clang_reparseTranslationUnit")] public static extern c_int ReparseTranslationUnit(CXTranslationUnit TU, c_uint num_unsaved_files, CXUnsavedFile* unsaved_files, c_uint options);
}

/** Categorizes how memory is being used by a translation unit.
 */
[CRepr, AllowDuplicates] enum CXTUResourceUsageKind : c_int
{
	AST = 1,
	Identifiers = 2,
	Selectors = 3,
	GlobalCompletionResults = 4,
	SourceManagerContentCache = 5,
	AST_SideTables = 6,
	SourceManager_Membuffer_Malloc = 7,
	SourceManager_Membuffer_MMap = 8,
	ExternalASTSource_Membuffer_Malloc = 9,
	ExternalASTSource_Membuffer_MMap = 10,
	Preprocessor = 11,
	PreprocessingRecord = 12,
	SourceManager_DataStructures = 13,
	Preprocessor_HeaderSearch = 14,
	MEMORY_IN_BYTES_BEGIN = AST,
	MEMORY_IN_BYTES_END = Preprocessor_HeaderSearch,
	First = AST,
	Last = Preprocessor_HeaderSearch,
}

extension Clang
{
	/** Returns the human-readable null-terminated C string that represents
	 *  the name of the memory category.  This string should never be freed.
	 */
	[Import(Clang.dll), LinkName("clang_getTUResourceUsageName")] public static extern c_char* GetTUResourceUsageName(CXTUResourceUsageKind kind);
}

[CRepr] struct CXTUResourceUsageEntry
{
	public CXTUResourceUsageKind kind;
	public c_ulong amount;
}

/** The memory usage of a CXTranslationUnit, broken into categories.
 */
[CRepr] struct CXTUResourceUsage
{
	public void* data;
	public c_uint numEntries;
	public CXTUResourceUsageEntry* entries;
}

extension Clang
{
	/** Return the memory usage of a translation unit.  This object
	 *  should be released with clang_disposeCXTUResourceUsage().
	 */
	[Import(Clang.dll), LinkName("clang_getCXTUResourceUsage")] public static extern CXTUResourceUsage GetCXTUResourceUsage(CXTranslationUnit TU);

	[Import(Clang.dll), LinkName("clang_disposeCXTUResourceUsage")] public static extern void DisposeCXTUResourceUsage(CXTUResourceUsage usage);

	/** Get target information for this translation unit.
	 *  The CXTargetInfo object cannot outlive the CXTranslationUnit object.
	 */
	[Import(Clang.dll), LinkName("clang_getTranslationUnitTargetInfo")] public static extern CXTargetInfo GetTranslationUnitTargetInfo(CXTranslationUnit CTUnit);

	/** Destroy the CXTargetInfo object.
	 */
	[Import(Clang.dll), LinkName("clang_TargetInfo_dispose")] public static extern void TargetInfo_Dispose(CXTargetInfo Info);

	/** Get the normalized target triple as a string.
	 *  Returns the empty string in case of any error.
	 */
	[Import(Clang.dll), LinkName("clang_TargetInfo_getTriple")] public static extern CXString TargetInfo_GetTriple(CXTargetInfo Info);

	/** Get the pointer width of the target in bits.
	 *  Returns -1 in case of error.
	 */
	[Import(Clang.dll), LinkName("clang_TargetInfo_getPointerWidth")] public static extern c_int TargetInfo_GetPointerWidth(CXTargetInfo Info);
}

/** Describes the kind of entity that a cursor refers to.
 */
[CRepr, AllowDuplicates] enum CXCursorKind : c_int
{
	/** A declaration whose specific kind is not exposed via this
	 *  interface.
	 *  Unexposed declarations have the same operations as any other kind
	 *  of declaration; one can extract their location information,
	 *  spelling, find their definitions, etc. However, the specific kind
	 *  of the declaration is not reported.
	 */
	UnexposedDecl = 1,

	/** A C or C++ struct. 
	 */
	StructDecl = 2,

	/** A C or C++ union. 
	 */
	UnionDecl = 3,

	/** A C++ class. 
	 */
	ClassDecl = 4,

	/** An enumeration. 
	 */
	EnumDecl = 5,

	/** A field (in C) or non-static data member (in C++) in a
	 *  struct, union, or C++ class.
	 */
	FieldDecl = 6,

	/** An enumerator constant. 
	 */
	EnumConstantDecl = 7,

	/** A function. 
	 */
	FunctionDecl = 8,

	/** A variable. 
	 */
	VarDecl = 9,

	/** A function or method parameter. 
	 */
	ParmDecl = 10,

	/** An Objective-C @interface.  
	 */
	ObjCInterfaceDecl = 11,

	/** An Objective-C @interface for a category.  
	 */
	ObjCCategoryDecl = 12,

	/** An Objective-C @protocol declaration.  
	 */
	ObjCProtocolDecl = 13,

	/** An Objective-C @property declaration.  
	 */
	ObjCPropertyDecl = 14,

	/** An Objective-C instance variable. 
	 */
	ObjCIvarDecl = 15,

	/** An Objective-C instance method. 
	 */
	ObjCInstanceMethodDecl = 16,

	/** An Objective-C class method. 
	 */
	ObjCClassMethodDecl = 17,

	/** An Objective-C @implementation.  
	 */
	ObjCImplementationDecl = 18,

	/** An Objective-C @implementation for a category.  
	 */
	ObjCCategoryImplDecl = 19,

	/** A typedef. 
	 */
	TypedefDecl = 20,

	/** A C++ class method. 
	 */
	CXXMethod = 21,

	/** A C++ namespace. 
	 */
	Namespace = 22,

	/** A linkage specification, e.g. 'extern "C"'. 
	 */
	LinkageSpec = 23,

	/** A C++ constructor. 
	 */
	Constructor = 24,

	/** A C++ destructor. 
	 */
	Destructor = 25,

	/** A C++ conversion function. 
	 */
	ConversionFunction = 26,

	/** A C++ template type parameter. 
	 */
	TemplateTypeParameter = 27,

	/** A C++ non-type template parameter. 
	 */
	NonTypeTemplateParameter = 28,

	/** A C++ template template parameter. 
	 */
	TemplateTemplateParameter = 29,

	/** A C++ function template. 
	 */
	FunctionTemplate = 30,

	/** A C++ class template. 
	 */
	ClassTemplate = 31,

	/** A C++ class template partial specialization. 
	 */
	ClassTemplatePartialSpecialization = 32,

	/** A C++ namespace alias declaration. 
	 */
	NamespaceAlias = 33,

	/** A C++ using directive. 
	 */
	UsingDirective = 34,

	/** A C++ using declaration. 
	 */
	UsingDeclaration = 35,

	/** A C++ alias declaration 
	 */
	TypeAliasDecl = 36,

	/** An Objective-C @synthesize definition.  
	 */
	ObjCSynthesizeDecl = 37,

	/** An Objective-C @dynamic definition.  
	 */
	ObjCDynamicDecl = 38,

	/** An access specifier. 
	 */
	CXXAccessSpecifier = 39,

	/** An access specifier. 
	 */
	FirstDecl = UnexposedDecl,

	/** An access specifier. 
	 */
	LastDecl = CXXAccessSpecifier,

	/** An access specifier. 
	 */
	FirstRef = 40,

	/** An access specifier. 
	 */
	ObjCSuperClassRef = 40,

	/** An access specifier. 
	 */
	ObjCProtocolRef = 41,

	/** An access specifier. 
	 */
	ObjCClassRef = 42,

	/** A reference to a type declaration.
	 *  A type reference occurs anywhere where a type is named but not
	 *  declared. For example, given:
	 *  
	 *  ```
	 *  typedef unsigned size_type;
	 *  size_type size;
	 *  ```
	 *  The typedef is a declaration of size_type (CXCursor_TypedefDecl),
	 *  while the type of the variable "size" is referenced. The cursor
	 *  referenced by the type of size is the typedef for size_type.
	 */
	TypeRef = 43,

	/** A reference to a type declaration.
	 *  A type reference occurs anywhere where a type is named but not
	 *  declared. For example, given:
	 *  
	 *  ```
	 *  typedef unsigned size_type;
	 *  size_type size;
	 *  ```
	 *  The typedef is a declaration of size_type (CXCursor_TypedefDecl),
	 *  while the type of the variable "size" is referenced. The cursor
	 *  referenced by the type of size is the typedef for size_type.
	 */
	CXXBaseSpecifier = 44,

	/** A reference to a class template, function template, template
	 *  template parameter, or class template partial specialization.
	 */
	TemplateRef = 45,

	/** A reference to a namespace or namespace alias.
	 */
	NamespaceRef = 46,

	/** A reference to a member of a struct, union, or class that occurs in
	 *  some non-expression context, e.g., a designated initializer.
	 */
	MemberRef = 47,

	/** A reference to a labeled statement.
	 *  This cursor kind is used to describe the jump to "start_over" in the
	 *  goto statement in the following example:
	 *  
	 *  ```
	 *  start_over:
	 *    ++counter;
	 *  
	 *    goto start_over;
	 *  ```
	 *  A label reference cursor refers to a label statement.
	 */
	LabelRef = 48,

	/** A reference to a set of overloaded functions or function templates
	 *  that has not yet been resolved to a specific function or function template.
	 *  An overloaded declaration reference cursor occurs in C++ templates where
	 *  a dependent name refers to a function. For example:
	 *  
	 *  ```
	 *  template<typename T> void swap(T&, T&);
	 *  
	 *  struct X { ... };
	 *  void swap(X&, X&);
	 *  
	 *  template<typename T>
	 *  void reverse(T* first, T* last) {
	 *  while (first < last - 1) {
	 *    swap(*first, *--last);
	 *    ++first;
	 *  }
	 *  }
	 *  
	 *  struct Y { };
	 *  void swap(Y&, Y&);
	 *  ```
	 *  Here, the identifier "swap" is associated with an overloaded declaration
	 *  reference. In the template definition, "swap" refers to either of the two
	 *  "swap" functions declared above, so both results will be available. At
	 *  instantiation time, "swap" may also refer to other functions found via
	 *  argument-dependent lookup (e.g., the "swap" function at the end of the
	 *  example).
	 *  The functions @c clang_getNumOverloadedDecls() and @c clang_getOverloadedDecl() can be used to retrieve the definitions referenced by this cursor.
	 */
	OverloadedDeclRef = 49,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	VariableRef = 50,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	LastRef = VariableRef,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	FirstInvalid = 70,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	InvalidFile = 70,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	NoDeclFound = 71,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	NotImplemented = 72,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	InvalidCode = 73,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	LastInvalid = InvalidCode,

	/** A reference to a variable that occurs in some non-expression
	 *  context, e.g., a C++ lambda capture list.
	 */
	FirstExpr = 100,

	/** An expression whose specific kind is not exposed via this
	 *  interface.
	 *  Unexposed expressions have the same operations as any other kind
	 *  of expression; one can extract their location information,
	 *  spelling, children, etc. However, the specific kind of the
	 *  expression is not reported.
	 */
	UnexposedExpr = 100,

	/** An expression that refers to some value declaration, such
	 *  as a function, variable, or enumerator.
	 */
	DeclRefExpr = 101,

	/** An expression that refers to a member of a struct, union,
	 *  class, Objective-C class, etc.
	 */
	MemberRefExpr = 102,

	/** An expression that calls a function. 
	 */
	CallExpr = 103,

	/** An expression that sends a message to an Objective-C
	 *  object or class. 
	 */
	ObjCMessageExpr = 104,

	/** An expression that represents a block literal. 
	 */
	BlockExpr = 105,

	/** An integer literal.
	 */
	IntegerLiteral = 106,

	/** A floating point number literal.
	 */
	FloatingLiteral = 107,

	/** An imaginary number literal.
	 */
	ImaginaryLiteral = 108,

	/** A string literal.
	 */
	StringLiteral = 109,

	/** A character literal.
	 */
	CharacterLiteral = 110,

	/** A parenthesized expression, e.g. "(1)".
	 *  This AST node is only formed if full location information is requested.
	 */
	ParenExpr = 111,

	/** This represents the unary-expression's (except sizeof and
	 *  alignof).
	 */
	UnaryOperator = 112,

	/** [C99 6.5.2.1] Array Subscripting.
	 */
	ArraySubscriptExpr = 113,

	/** A builtin binary operation expression such as "x + y" or
	 *  "x <= y".
	 */
	BinaryOperator = 114,

	/** Compound assignment such as "+=".
	 */
	CompoundAssignOperator = 115,

	/** The ?: ternary operator.
	 */
	ConditionalOperator = 116,

	/** An explicit cast in C (C99 6.5.4) or a C-style cast in C++
	 *  (C++ [expr.cast]), which uses the syntax (Type)expr.
	 *  For example: (int)f.
	 */
	CStyleCastExpr = 117,

	/** [C99 6.5.2.5]
	 */
	CompoundLiteralExpr = 118,

	/** Describes an C or C++ initializer list.
	 */
	InitListExpr = 119,

	/** The GNU address of label extension, representing 
	 *  &
	 *  &label
	 *  .
	 */
	AddrLabelExpr = 120,

	/** This is the GNU Statement Expression extension: ({int X=4; X;})
	 */
	StmtExpr = 121,

	/** Represents a C11 generic selection.
	 */
	GenericSelectionExpr = 122,

	/** Implements the GNU __null extension, which is a name for a null
	 *  pointer constant that has integral type (e.g., int or long) and is the same
	 *  size and alignment as a pointer.
	 *  The __null extension is typically only used by system headers, which define
	 *  NULL as __null in C++ rather than using 0 (which is an integer that may not
	 *  match the size of a pointer).
	 */
	GNUNullExpr = 123,

	/** C++'s static_cast
	 *  <
	 *  > expression.
	 */
	CXXStaticCastExpr = 124,

	/** C++'s dynamic_cast
	 *  <
	 *  > expression.
	 */
	CXXDynamicCastExpr = 125,

	/** C++'s reinterpret_cast
	 *  <
	 *  > expression.
	 */
	CXXReinterpretCastExpr = 126,

	/** C++'s const_cast
	 *  <
	 *  > expression.
	 */
	CXXConstCastExpr = 127,

	/** Represents an explicit C++ type conversion that uses "functional"
	 *  notion (C++ [expr.type.conv]).
	 *  Example:
	 *  
	 *  ```
	 *  x = int(0.5);
	 *  ```
	 *  
	 */
	CXXFunctionalCastExpr = 128,

	/** A C++ typeid expression (C++ [expr.typeid]).
	 */
	CXXTypeidExpr = 129,

	/** [C++ 2.13.5] C++ Boolean Literal.
	 */
	CXXBoolLiteralExpr = 130,

	/** [C++0x 2.14.7] C++ Pointer Literal.
	 */
	CXXNullPtrLiteralExpr = 131,

	/** Represents the "this" expression in C++
	 */
	CXXThisExpr = 132,

	/** [C++ 15] C++ Throw Expression.
	 *  This handles 'throw' and 'throw' assignment-expression. When
	 *  assignment-expression isn't present, Op will be null.
	 */
	CXXThrowExpr = 133,

	/** A new expression for memory allocation and constructor calls, e.g:
	 *  "new CXXNewExpr(foo)".
	 */
	CXXNewExpr = 134,

	/** A delete expression for memory deallocation and destructor calls,
	 *  e.g. "delete[] pArray".
	 */
	CXXDeleteExpr = 135,

	/** A unary expression. (noexcept, sizeof, or other traits)
	 */
	UnaryExpr = 136,

	/** An Objective-C string literal i.e. 
	 *  "
	 *  foo".
	 */
	ObjCStringLiteral = 137,

	/** An Objective-C @encode expression. 
	 */
	ObjCEncodeExpr = 138,

	/** An Objective-C @selector expression. 
	 */
	ObjCSelectorExpr = 139,

	/** An Objective-C @protocol expression. 
	 */
	ObjCProtocolExpr = 140,

	/** An Objective-C "bridged" cast expression, which casts between
	 *  Objective-C pointers and C pointers, transferring ownership in the process.
	 *  
	 *  ```
	 *  NSString *str = (__bridge_transfer NSString *)CFCreateString();
	 *  ```
	 *  
	 */
	ObjCBridgedCastExpr = 141,

	/** Represents a C++0x pack expansion that produces a sequence of
	 *  expressions.
	 *  A pack expansion expression contains a pattern (which itself is an
	 *  expression) followed by an ellipsis. For example:
	 *  
	 *  ```
	 *  template<typename F, typename ...Types>
	 *  void forward(F f, Types &&...args) {
	 *  f(static_cast<Types&&>(args)...);
	 *  }
	 *  ```
	 *  
	 */
	PackExpansionExpr = 142,

	/** Represents an expression that computes the length of a parameter
	 *  pack.
	 *  
	 *  ```
	 *  template<typename ...Types>
	 *  struct count {
	 *  static const unsigned value = sizeof...(Types);
	 *  };
	 *  ```
	 *  
	 */
	SizeOfPackExpr = 143,

	LambdaExpr = 144,

	/** Objective-c Boolean Literal.
	 */
	ObjCBoolLiteralExpr = 145,

	/** Represents the "self" expression in an Objective-C method.
	 */
	ObjCSelfExpr = 146,

	/** OpenMP 5.0 [2.1.5, Array Section].
	 *  OpenACC 3.3 [2.7.1, Data Specification for Data Clauses (Sub Arrays)]
	 */
	ArraySectionExpr = 147,

	/** Represents an @available (...) check. 
	 */
	ObjCAvailabilityCheckExpr = 148,

	/** Fixed point literal
	 */
	FixedPointLiteral = 149,

	/** OpenMP 5.0 [2.1.4, Array Shaping].
	 */
	OMPArrayShapingExpr = 150,

	/** OpenMP 5.0 [2.1.6 Iterators]
	 */
	OMPIteratorExpr = 151,

	/** OpenCL's addrspace_cast
	 *  <
	 *  > expression.
	 */
	CXXAddrspaceCastExpr = 152,

	/** Expression that references a C++20 concept.
	 */
	ConceptSpecializationExpr = 153,

	/** Expression that references a C++20 requires expression.
	 */
	RequiresExpr = 154,

	/** Expression that references a C++20 parenthesized list aggregate
	 *  initializer.
	 */
	CXXParenListInitExpr = 155,

	/** Represents a C++26 pack indexing expression.
	 */
	PackIndexingExpr = 156,

	/** Represents a C++26 pack indexing expression.
	 */
	LastExpr = PackIndexingExpr,

	/** Represents a C++26 pack indexing expression.
	 */
	FirstStmt = 200,

	/** A statement whose specific kind is not exposed via this
	 *  interface.
	 *  Unexposed statements have the same operations as any other kind of
	 *  statement; one can extract their location information, spelling,
	 *  children, etc. However, the specific kind of the statement is not
	 *  reported.
	 */
	UnexposedStmt = 200,

	/** A labelled statement in a function.
	 *  This cursor kind is used to describe the "start_over:" label statement in
	 *  the following example:
	 *  
	 *  ```
	 *  start_over:
	 *    ++counter;
	 *  ```
	 *  
	 */
	LabelStmt = 201,

	/** A group of statements like { stmt stmt }.
	 *  This cursor kind is used to describe compound statements, e.g. function
	 *  bodies.
	 */
	CompoundStmt = 202,

	/** A case statement.
	 */
	CaseStmt = 203,

	/** A default statement.
	 */
	DefaultStmt = 204,

	/** An if statement
	 */
	IfStmt = 205,

	/** A switch statement.
	 */
	SwitchStmt = 206,

	/** A while statement.
	 */
	WhileStmt = 207,

	/** A do statement.
	 */
	DoStmt = 208,

	/** A for statement.
	 */
	ForStmt = 209,

	/** A goto statement.
	 */
	GotoStmt = 210,

	/** An indirect goto statement.
	 */
	IndirectGotoStmt = 211,

	/** A continue statement.
	 */
	ContinueStmt = 212,

	/** A break statement.
	 */
	BreakStmt = 213,

	/** A return statement.
	 */
	ReturnStmt = 214,

	/** A GCC inline assembly statement extension.
	 */
	GCCAsmStmt = 215,

	/** A GCC inline assembly statement extension.
	 */
	AsmStmt = GCCAsmStmt,

	/** Objective-C's overall @try- @catch- @finally statement. 
	 */
	ObjCAtTryStmt = 216,

	/** Objective-C's @catch statement. 
	 */
	ObjCAtCatchStmt = 217,

	/** Objective-C's @finally statement. 
	 */
	ObjCAtFinallyStmt = 218,

	/** Objective-C's @throw statement. 
	 */
	ObjCAtThrowStmt = 219,

	/** Objective-C's @synchronized statement. 
	 */
	ObjCAtSynchronizedStmt = 220,

	/** Objective-C's autorelease pool statement.
	 */
	ObjCAutoreleasePoolStmt = 221,

	/** Objective-C's collection statement.
	 */
	ObjCForCollectionStmt = 222,

	/** C++'s catch statement.
	 */
	CXXCatchStmt = 223,

	/** C++'s try statement.
	 */
	CXXTryStmt = 224,

	/** C++'s for (* : *) statement.
	 */
	CXXForRangeStmt = 225,

	/** Windows Structured Exception Handling's try statement.
	 */
	SEHTryStmt = 226,

	/** Windows Structured Exception Handling's except statement.
	 */
	SEHExceptStmt = 227,

	/** Windows Structured Exception Handling's finally statement.
	 */
	SEHFinallyStmt = 228,

	/** A MS inline assembly statement extension.
	 */
	MSAsmStmt = 229,

	/** The null statement ";": C99 6.8.3p3.
	 *  This cursor kind is used to describe the null statement.
	 */
	NullStmt = 230,

	/** Adaptor class for mixing declarations with statements and
	 *  expressions.
	 */
	DeclStmt = 231,

	/** OpenMP parallel directive.
	 */
	OMPParallelDirective = 232,

	/** OpenMP SIMD directive.
	 */
	OMPSimdDirective = 233,

	/** OpenMP for directive.
	 */
	OMPForDirective = 234,

	/** OpenMP sections directive.
	 */
	OMPSectionsDirective = 235,

	/** OpenMP section directive.
	 */
	OMPSectionDirective = 236,

	/** OpenMP single directive.
	 */
	OMPSingleDirective = 237,

	/** OpenMP parallel for directive.
	 */
	OMPParallelForDirective = 238,

	/** OpenMP parallel sections directive.
	 */
	OMPParallelSectionsDirective = 239,

	/** OpenMP task directive.
	 */
	OMPTaskDirective = 240,

	/** OpenMP master directive.
	 */
	OMPMasterDirective = 241,

	/** OpenMP critical directive.
	 */
	OMPCriticalDirective = 242,

	/** OpenMP taskyield directive.
	 */
	OMPTaskyieldDirective = 243,

	/** OpenMP barrier directive.
	 */
	OMPBarrierDirective = 244,

	/** OpenMP taskwait directive.
	 */
	OMPTaskwaitDirective = 245,

	/** OpenMP flush directive.
	 */
	OMPFlushDirective = 246,

	/** Windows Structured Exception Handling's leave statement.
	 */
	SEHLeaveStmt = 247,

	/** OpenMP ordered directive.
	 */
	OMPOrderedDirective = 248,

	/** OpenMP atomic directive.
	 */
	OMPAtomicDirective = 249,

	/** OpenMP for SIMD directive.
	 */
	OMPForSimdDirective = 250,

	/** OpenMP parallel for SIMD directive.
	 */
	OMPParallelForSimdDirective = 251,

	/** OpenMP target directive.
	 */
	OMPTargetDirective = 252,

	/** OpenMP teams directive.
	 */
	OMPTeamsDirective = 253,

	/** OpenMP taskgroup directive.
	 */
	OMPTaskgroupDirective = 254,

	/** OpenMP cancellation point directive.
	 */
	OMPCancellationPointDirective = 255,

	/** OpenMP cancel directive.
	 */
	OMPCancelDirective = 256,

	/** OpenMP target data directive.
	 */
	OMPTargetDataDirective = 257,

	/** OpenMP taskloop directive.
	 */
	OMPTaskLoopDirective = 258,

	/** OpenMP taskloop simd directive.
	 */
	OMPTaskLoopSimdDirective = 259,

	/** OpenMP distribute directive.
	 */
	OMPDistributeDirective = 260,

	/** OpenMP target enter data directive.
	 */
	OMPTargetEnterDataDirective = 261,

	/** OpenMP target exit data directive.
	 */
	OMPTargetExitDataDirective = 262,

	/** OpenMP target parallel directive.
	 */
	OMPTargetParallelDirective = 263,

	/** OpenMP target parallel for directive.
	 */
	OMPTargetParallelForDirective = 264,

	/** OpenMP target update directive.
	 */
	OMPTargetUpdateDirective = 265,

	/** OpenMP distribute parallel for directive.
	 */
	OMPDistributeParallelForDirective = 266,

	/** OpenMP distribute parallel for simd directive.
	 */
	OMPDistributeParallelForSimdDirective = 267,

	/** OpenMP distribute simd directive.
	 */
	OMPDistributeSimdDirective = 268,

	/** OpenMP target parallel for simd directive.
	 */
	OMPTargetParallelForSimdDirective = 269,

	/** OpenMP target simd directive.
	 */
	OMPTargetSimdDirective = 270,

	/** OpenMP teams distribute directive.
	 */
	OMPTeamsDistributeDirective = 271,

	/** OpenMP teams distribute simd directive.
	 */
	OMPTeamsDistributeSimdDirective = 272,

	/** OpenMP teams distribute parallel for simd directive.
	 */
	OMPTeamsDistributeParallelForSimdDirective = 273,

	/** OpenMP teams distribute parallel for directive.
	 */
	OMPTeamsDistributeParallelForDirective = 274,

	/** OpenMP target teams directive.
	 */
	OMPTargetTeamsDirective = 275,

	/** OpenMP target teams distribute directive.
	 */
	OMPTargetTeamsDistributeDirective = 276,

	/** OpenMP target teams distribute parallel for directive.
	 */
	OMPTargetTeamsDistributeParallelForDirective = 277,

	/** OpenMP target teams distribute parallel for simd directive.
	 */
	OMPTargetTeamsDistributeParallelForSimdDirective = 278,

	/** OpenMP target teams distribute simd directive.
	 */
	OMPTargetTeamsDistributeSimdDirective = 279,

	/** C++2a std::bit_cast expression.
	 */
	BuiltinBitCastExpr = 280,

	/** OpenMP master taskloop directive.
	 */
	OMPMasterTaskLoopDirective = 281,

	/** OpenMP parallel master taskloop directive.
	 */
	OMPParallelMasterTaskLoopDirective = 282,

	/** OpenMP master taskloop simd directive.
	 */
	OMPMasterTaskLoopSimdDirective = 283,

	/** OpenMP parallel master taskloop simd directive.
	 */
	OMPParallelMasterTaskLoopSimdDirective = 284,

	/** OpenMP parallel master directive.
	 */
	OMPParallelMasterDirective = 285,

	/** OpenMP depobj directive.
	 */
	OMPDepobjDirective = 286,

	/** OpenMP scan directive.
	 */
	OMPScanDirective = 287,

	/** OpenMP tile directive.
	 */
	OMPTileDirective = 288,

	/** OpenMP canonical loop.
	 */
	OMPCanonicalLoop = 289,

	/** OpenMP interop directive.
	 */
	OMPInteropDirective = 290,

	/** OpenMP dispatch directive.
	 */
	OMPDispatchDirective = 291,

	/** OpenMP masked directive.
	 */
	OMPMaskedDirective = 292,

	/** OpenMP unroll directive.
	 */
	OMPUnrollDirective = 293,

	/** OpenMP metadirective directive.
	 */
	OMPMetaDirective = 294,

	/** OpenMP loop directive.
	 */
	OMPGenericLoopDirective = 295,

	/** OpenMP teams loop directive.
	 */
	OMPTeamsGenericLoopDirective = 296,

	/** OpenMP target teams loop directive.
	 */
	OMPTargetTeamsGenericLoopDirective = 297,

	/** OpenMP parallel loop directive.
	 */
	OMPParallelGenericLoopDirective = 298,

	/** OpenMP target parallel loop directive.
	 */
	OMPTargetParallelGenericLoopDirective = 299,

	/** OpenMP parallel masked directive.
	 */
	OMPParallelMaskedDirective = 300,

	/** OpenMP masked taskloop directive.
	 */
	OMPMaskedTaskLoopDirective = 301,

	/** OpenMP masked taskloop simd directive.
	 */
	OMPMaskedTaskLoopSimdDirective = 302,

	/** OpenMP parallel masked taskloop directive.
	 */
	OMPParallelMaskedTaskLoopDirective = 303,

	/** OpenMP parallel masked taskloop simd directive.
	 */
	OMPParallelMaskedTaskLoopSimdDirective = 304,

	/** OpenMP error directive.
	 */
	OMPErrorDirective = 305,

	/** OpenMP scope directive.
	 */
	OMPScopeDirective = 306,

	/** OpenMP reverse directive.
	 */
	OMPReverseDirective = 307,

	/** OpenMP interchange directive.
	 */
	OMPInterchangeDirective = 308,

	/** OpenMP assume directive.
	 */
	OMPAssumeDirective = 309,

	/** OpenMP assume directive.
	 */
	OMPStripeDirective = 310,

	/** OpenACC Compute Construct.
	 */
	OpenACCComputeConstruct = 320,

	/** OpenACC Loop Construct.
	 */
	OpenACCLoopConstruct = 321,

	/** OpenACC Combined Constructs.
	 */
	OpenACCCombinedConstruct = 322,

	/** OpenACC data Construct.
	 */
	OpenACCDataConstruct = 323,

	/** OpenACC enter data Construct.
	 */
	OpenACCEnterDataConstruct = 324,

	/** OpenACC exit data Construct.
	 */
	OpenACCExitDataConstruct = 325,

	/** OpenACC host_data Construct.
	 */
	OpenACCHostDataConstruct = 326,

	/** OpenACC wait Construct.
	 */
	OpenACCWaitConstruct = 327,

	/** OpenACC init Construct.
	 */
	OpenACCInitConstruct = 328,

	/** OpenACC shutdown Construct.
	 */
	OpenACCShutdownConstruct = 329,

	/** OpenACC set Construct.
	 */
	OpenACCSetConstruct = 330,

	/** OpenACC update Construct.
	 */
	OpenACCUpdateConstruct = 331,

	/** OpenACC atomic Construct.
	 */
	OpenACCAtomicConstruct = 332,

	/** OpenACC cache Construct.
	 */
	OpenACCCacheConstruct = 333,

	/** OpenACC cache Construct.
	 */
	LastStmt = OpenACCCacheConstruct,

	/** Cursor that represents the translation unit itself.
	 *  The translation unit cursor exists primarily to act as the root
	 *  cursor for traversing the contents of a translation unit.
	 */
	TranslationUnit = 350,

	/** Cursor that represents the translation unit itself.
	 *  The translation unit cursor exists primarily to act as the root
	 *  cursor for traversing the contents of a translation unit.
	 */
	FirstAttr = 400,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	UnexposedAttr = 400,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	IBActionAttr = 401,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	IBOutletAttr = 402,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	IBOutletCollectionAttr = 403,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CXXFinalAttr = 404,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CXXOverrideAttr = 405,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	AnnotateAttr = 406,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	AsmLabelAttr = 407,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	PackedAttr = 408,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	PureAttr = 409,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ConstAttr = 410,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	NoDuplicateAttr = 411,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CUDAConstantAttr = 412,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CUDADeviceAttr = 413,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CUDAGlobalAttr = 414,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CUDAHostAttr = 415,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	CUDASharedAttr = 416,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	VisibilityAttr = 417,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	DLLExport = 418,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	DLLImport = 419,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	NSReturnsRetained = 420,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	NSReturnsNotRetained = 421,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	NSReturnsAutoreleased = 422,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	NSConsumesSelf = 423,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	NSConsumed = 424,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCException = 425,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCNSObject = 426,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCIndependentClass = 427,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCPreciseLifetime = 428,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCReturnsInnerPointer = 429,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCRequiresSuper = 430,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCRootClass = 431,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCSubclassingRestricted = 432,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCExplicitProtocolImpl = 433,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCDesignatedInitializer = 434,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCRuntimeVisible = 435,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCBoxable = 436,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	FlagEnum = 437,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	ConvergentAttr = 438,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	WarnUnusedAttr = 439,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	WarnUnusedResultAttr = 440,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	AlignedAttr = 441,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	LastAttr = AlignedAttr,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	PreprocessingDirective = 500,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	MacroDefinition = 501,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	MacroExpansion = 502,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	MacroInstantiation = MacroExpansion,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	InclusionDirective = 503,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	FirstPreprocessing = PreprocessingDirective,

	/** An attribute whose specific kind is not exposed via this
	 *  interface.
	 */
	LastPreprocessing = InclusionDirective,

	/** A module import declaration.
	 */
	ModuleImportDecl = 600,

	/** A module import declaration.
	 */
	TypeAliasTemplateDecl = 601,

	/** A static_assert or _Static_assert node
	 */
	StaticAssert = 602,

	/** a friend declaration.
	 */
	FriendDecl = 603,

	/** a concept declaration.
	 */
	ConceptDecl = 604,

	/** a concept declaration.
	 */
	FirstExtraDecl = ModuleImportDecl,

	/** a concept declaration.
	 */
	LastExtraDecl = ConceptDecl,

	/** A code completion overload candidate.
	 */
	OverloadCandidate = 700,
}

/** A cursor representing some element in the abstract syntax tree for
 *  a translation unit.
 *  The cursor abstraction unifies the different kinds of entities in a
 *  program--declaration, statements, expressions, references to declarations,
 *  etc.--under a single "cursor" abstraction with a common set of operations.
 *  Common operation for a cursor include: getting the physical location in
 *  a source file where the cursor points, getting the name associated with a
 *  cursor, and retrieving cursors for any child nodes of a particular cursor.
 *  Cursors can be produced in two specific ways.
 *  clang_getTranslationUnitCursor() produces a cursor for a translation unit,
 *  from which one can use clang_visitChildren() to explore the rest of the
 *  translation unit. clang_getCursor() maps from a physical source location
 *  to the entity that resides at that location, allowing one to map from the
 *  source code into the AST.
 */
[CRepr] struct CXCursor
{
	public CXCursorKind kind;
	public c_int xdata;
	public void*[3] data;
}

extension Clang
{
	/** Retrieve the NULL cursor, which represents no entity.
	 */
	[Import(Clang.dll), LinkName("clang_getNullCursor")] public static extern CXCursor GetNullCursor();

	/** Retrieve the cursor that represents the given translation unit.
	 *  The translation unit cursor can be used to start traversing the
	 *  various declarations within the given translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getTranslationUnitCursor")] public static extern CXCursor GetTranslationUnitCursor(CXTranslationUnit);

	/** Determine whether two cursors are equivalent.
	 */
	[Import(Clang.dll), LinkName("clang_equalCursors")] public static extern c_uint EqualCursors(CXCursor, CXCursor);

	/** Returns non-zero if @p cursor is null. 
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isNull")] public static extern c_int Cursor_IsNull(CXCursor cursor);

	/** Compute a hash value for the given cursor.
	 */
	[Import(Clang.dll), LinkName("clang_hashCursor")] public static extern c_uint HashCursor(CXCursor);

	/** Retrieve the kind of the given cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorKind")] public static extern CXCursorKind GetCursorKind(CXCursor);

	/** Determine whether the given cursor kind represents a declaration.
	 */
	[Import(Clang.dll), LinkName("clang_isDeclaration")] public static extern c_uint IsDeclaration(CXCursorKind);

	/** Determine whether the given declaration is invalid.
	 *  A declaration is invalid if it could not be parsed successfully.
	 *  
	 *  @returns non-zero if the cursor represents a declaration and it is
	 *  invalid, otherwise NULL.
	 */
	[Import(Clang.dll), LinkName("clang_isInvalidDeclaration")] public static extern c_uint IsInvalidDeclaration(CXCursor);

	/** Determine whether the given cursor kind represents a simple
	 *  reference.
	 *  Note that other kinds of cursors (such as expressions) can also refer to
	 *  other cursors. Use clang_getCursorReferenced() to determine whether a
	 *  particular cursor refers to another entity.
	 */
	[Import(Clang.dll), LinkName("clang_isReference")] public static extern c_uint IsReference(CXCursorKind);

	/** Determine whether the given cursor kind represents an expression.
	 */
	[Import(Clang.dll), LinkName("clang_isExpression")] public static extern c_uint IsExpression(CXCursorKind);

	/** Determine whether the given cursor kind represents a statement.
	 */
	[Import(Clang.dll), LinkName("clang_isStatement")] public static extern c_uint IsStatement(CXCursorKind);

	/** Determine whether the given cursor kind represents an attribute.
	 */
	[Import(Clang.dll), LinkName("clang_isAttribute")] public static extern c_uint IsAttribute(CXCursorKind);

	/** Determine whether the given cursor has any attributes.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_hasAttrs")] public static extern c_uint Cursor_HasAttrs(CXCursor C);

	/** Determine whether the given cursor kind represents an invalid
	 *  cursor.
	 */
	[Import(Clang.dll), LinkName("clang_isInvalid")] public static extern c_uint IsInvalid(CXCursorKind);

	/** Determine whether the given cursor kind represents a translation
	 *  unit.
	 */
	[Import(Clang.dll), LinkName("clang_isTranslationUnit")] public static extern c_uint IsTranslationUnit(CXCursorKind);

	/** *
	 *  Determine whether the given cursor represents a preprocessing
	 *  element, such as a preprocessor directive or macro instantiation.
	 */
	[Import(Clang.dll), LinkName("clang_isPreprocessing")] public static extern c_uint IsPreprocessing(CXCursorKind);

	/** *
	 *  Determine whether the given cursor represents a currently
	 *  unexposed piece of the AST (e.g., CXCursor_UnexposedStmt).
	 */
	[Import(Clang.dll), LinkName("clang_isUnexposed")] public static extern c_uint IsUnexposed(CXCursorKind);
}

/** Describe the linkage of the entity referred to by a cursor.
 */
[CRepr, AllowDuplicates] enum CXLinkageKind : c_int
{
	/** This value indicates that no linkage information is available
	 *  for a provided CXCursor. 
	 */
	Invalid = 0,

	/** This is the linkage for variables, parameters, and so on that
	 *  have automatic storage.  This covers normal (non-extern) local variables.
	 */
	NoLinkage = 1,

	/** This is the linkage for static variables and static functions. 
	 */
	Internal = 2,

	/** This is the linkage for entities with external linkage that live
	 *  in C++ anonymous namespaces.
	 */
	UniqueExternal = 3,

	/** This is the linkage for entities with true, external linkage. 
	 */
	External = 4,
}

extension Clang
{
	/** Determine the linkage of the entity referred to by a given cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorLinkage")] public static extern CXLinkageKind GetCursorLinkage(CXCursor cursor);
}

[CRepr, AllowDuplicates] enum CXVisibilityKind : c_int
{
	/** This value indicates that no visibility information is available
	 *  for a provided CXCursor. 
	 */
	Invalid = 0,

	/** Symbol not seen by the linker. 
	 */
	Hidden = 1,

	/** Symbol seen by the linker but resolves to a symbol inside this object. 
	 */
	Protected = 2,

	/** Symbol seen by the linker and acts like a normal symbol. 
	 */
	Default = 3,
}

extension Clang
{
	/** Describe the visibility of the entity referred to by a cursor.
	 *  This returns the default visibility if not explicitly specified by
	 *  a visibility attribute. The default visibility may be changed by
	 *  commandline arguments.
	 *  
	 *  @param cursor The cursor to query.
	 *  
	 *  @returns The visibility of the cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorVisibility")] public static extern CXVisibilityKind GetCursorVisibility(CXCursor cursor);

	/** Determine the availability of the entity that this cursor refers to,
	 *  taking the current target platform into account.
	 *  
	 *  @param cursor The cursor to query.
	 *  
	 *  @returns The availability of the cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorAvailability")] public static extern CXAvailabilityKind GetCursorAvailability(CXCursor cursor);
}

/** Describes the availability of a given entity on a particular platform, e.g.,
 *  a particular class might only be available on Mac OS 10.7 or newer.
 */
[CRepr] struct CXPlatformAvailability
{
	/** A string that describes the platform for which this structure
	 *  provides availability information.
	 *  Possible values are "ios" or "macos".
	 */
	public CXString Platform;

	/** The version number in which this entity was introduced.
	 */
	public CXVersion Introduced;

	/** The version number in which this entity was deprecated (but is
	 *  still available).
	 */
	public CXVersion Deprecated;

	/** The version number in which this entity was obsoleted, and therefore
	 *  is no longer available.
	 */
	public CXVersion Obsoleted;

	/** Whether the entity is unconditionally unavailable on this platform.
	 */
	public c_int Unavailable;

	/** An optional message to provide to a user of this API, e.g., to
	 *  suggest replacement APIs.
	 */
	public CXString Message;
}

extension Clang
{
	/** Determine the availability of the entity that this cursor refers to
	 *  on any platforms for which availability information is known.
	 *  
	 *  @param cursor The cursor to query.
	 *  
	 *  @param always_deprecated If non-NULL, will be set to indicate whether the
	 *  entity is deprecated on all platforms.
	 *  
	 *  @param deprecated_message If non-NULL, will be set to the message text
	 *  provided along with the unconditional deprecation of this entity. The client
	 *  is responsible for deallocating this string.
	 *  
	 *  @param always_unavailable If non-NULL, will be set to indicate whether the
	 *  entity is unavailable on all platforms.
	 *  
	 *  @param unavailable_message If non-NULL, will be set to the message text
	 *  provided along with the unconditional unavailability of this entity. The
	 *  client is responsible for deallocating this string.
	 *  
	 *  @param availability If non-NULL, an array of CXPlatformAvailability instances
	 *  that will be populated with platform availability information, up to either
	 *  the number of platforms for which availability information is available (as
	 *  returned by this function) or @c availability_size, whichever is smaller. 
	 *  
	 *  @param availability_size The number of elements available in the
	 *  @c availability array. 
	 *  
	 *  @returns The number of platforms (N) for which availability information is
	 *  available (which is unrelated to @c availability_size). 
	 *  Note that the client is responsible for calling @c clang_disposeCXPlatformAvailability to free each of the platform-availability structures returned. There are
	 *  @c min(N, availability_size) such structures. 
	 */
	[Import(Clang.dll), LinkName("clang_getCursorPlatformAvailability")] public static extern c_int GetCursorPlatformAvailability(CXCursor cursor, c_int* always_deprecated, CXString* deprecated_message, c_int* always_unavailable, CXString* unavailable_message, CXPlatformAvailability* availability, c_int availability_size);

	/** Free the memory associated with a @c CXPlatformAvailability structure. 
	 */
	[Import(Clang.dll), LinkName("clang_disposeCXPlatformAvailability")] public static extern void DisposeCXPlatformAvailability(CXPlatformAvailability* availability);

	/** If cursor refers to a variable declaration and it has initializer returns
	 *  cursor referring to the initializer otherwise return null cursor.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getVarDeclInitializer")] public static extern CXCursor Cursor_GetVarDeclInitializer(CXCursor cursor);

	/** If cursor refers to a variable declaration that has global storage returns 1.
	 *  If cursor refers to a variable declaration that doesn't have global storage
	 *  returns 0. Otherwise returns -1.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_hasVarDeclGlobalStorage")] public static extern c_int Cursor_HasVarDeclGlobalStorage(CXCursor cursor);

	/** If cursor refers to a variable declaration that has external storage
	 *  returns 1. If cursor refers to a variable declaration that doesn't have
	 *  external storage returns 0. Otherwise returns -1.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_hasVarDeclExternalStorage")] public static extern c_int Cursor_HasVarDeclExternalStorage(CXCursor cursor);
}

/** Describe the "language" of the entity referred to by a cursor.
 */
[CRepr, AllowDuplicates] enum CXLanguageKind : c_int
{
	Invalid = 0,
	C = 1,
	ObjC = 2,
	CPlusPlus = 3,
}

extension Clang
{
	/** Determine the "language" of the entity referred to by a given cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorLanguage")] public static extern CXLanguageKind GetCursorLanguage(CXCursor cursor);
}

/** Describe the "thread-local storage (TLS) kind" of the declaration
 *  referred to by a cursor.
 */
[CRepr, AllowDuplicates] enum CXTLSKind : c_int
{
	None = 0,
	Dynamic = 1,
	Static = 2,
}

extension Clang
{
	/** Determine the "thread-local storage (TLS) kind" of the declaration
	 *  referred to by a cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorTLSKind")] public static extern CXTLSKind GetCursorTLSKind(CXCursor cursor);

	/** Returns the translation unit that a cursor originated from.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getTranslationUnit")] public static extern CXTranslationUnit Cursor_GetTranslationUnit(CXCursor);
}

/** A fast container representing a set of CXCursors.
 */
class CXCursorSet { private this() {} }

extension Clang
{
	/** Creates an empty CXCursorSet.
	 */
	[Import(Clang.dll), LinkName("clang_createCXCursorSet")] public static extern CXCursorSet CreateCXCursorSet();

	/** Disposes a CXCursorSet and releases its associated memory.
	 */
	[Import(Clang.dll), LinkName("clang_disposeCXCursorSet")] public static extern void DisposeCXCursorSet(CXCursorSet cset);

	/** Queries a CXCursorSet to see if it contains a specific CXCursor.
	 *  
	 *  @returns non-zero if the set contains the specified cursor.
	 */
	[Import(Clang.dll), LinkName("clang_CXCursorSet_contains")] public static extern c_uint CXCursorSet_Contains(CXCursorSet cset, CXCursor cursor);

	/** Inserts a CXCursor into a CXCursorSet.
	 *  
	 *  @returns zero if the CXCursor was already in the set, and non-zero otherwise.
	 */
	[Import(Clang.dll), LinkName("clang_CXCursorSet_insert")] public static extern c_uint CXCursorSet_Insert(CXCursorSet cset, CXCursor cursor);

	/** Determine the semantic parent of the given cursor.
	 *  The semantic parent of a cursor is the cursor that semantically contains
	 *  the given @p cursor. For many declarations, the lexical and semantic parents are equivalent (the lexical parent is returned by
	 *  @c clang_getCursorLexicalParent()). They diverge when declarations or definitions are provided out-of-line. For example:
	 *  
	 *  ```
	 *  class C {
	 *  void f();
	 *  };
	 *  
	 *  void C::f() { }
	 *  ```
	 *  In the out-of-line definition of @c C::f, the semantic parent is the class @c C, of which this function is a member. The lexical parent is the place where the declaration actually occurs in the source code; in this
	 *  case, the definition occurs in the translation unit. In general, the
	 *  lexical parent for a given entity can change without affecting the semantics
	 *  of the program, and the lexical parent of different declarations of the
	 *  same entity may be different. Changing the semantic parent of a declaration,
	 *  on the other hand, can have a major impact on semantics, and redeclarations
	 *  of a particular entity should all have the same semantic context.
	 *  In the example above, both declarations of @c C::f have  @c C as their semantic context, while the lexical context of the first @c C::f is  @c C and the lexical context of the second  @c C::f is the translation unit. 
	 *  For global declarations, the semantic parent is the translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorSemanticParent")] public static extern CXCursor GetCursorSemanticParent(CXCursor cursor);

	/** Determine the lexical parent of the given cursor.
	 *  The lexical parent of a cursor is the cursor in which the given @p cursor was actually written. For many declarations, the lexical and semantic parents are equivalent (the semantic parent is returned by
	 *  @c clang_getCursorSemanticParent()). They diverge when declarations or definitions are provided out-of-line. For example:
	 *  
	 *  ```
	 *  class C {
	 *  void f();
	 *  };
	 *  
	 *  void C::f() { }
	 *  ```
	 *  In the out-of-line definition of @c C::f, the semantic parent is the class @c C, of which this function is a member. The lexical parent is the place where the declaration actually occurs in the source code; in this
	 *  case, the definition occurs in the translation unit. In general, the
	 *  lexical parent for a given entity can change without affecting the semantics
	 *  of the program, and the lexical parent of different declarations of the
	 *  same entity may be different. Changing the semantic parent of a declaration,
	 *  on the other hand, can have a major impact on semantics, and redeclarations
	 *  of a particular entity should all have the same semantic context.
	 *  In the example above, both declarations of @c C::f have  @c C as their semantic context, while the lexical context of the first @c C::f is  @c C and the lexical context of the second  @c C::f is the translation unit. 
	 *  For declarations written in the global scope, the lexical parent is
	 *  the translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorLexicalParent")] public static extern CXCursor GetCursorLexicalParent(CXCursor cursor);

	/** Determine the set of methods that are overridden by the given
	 *  method.
	 *  In both Objective-C and C++, a method (aka virtual member function,
	 *  in C++) can override a virtual method in a base class. For
	 *  Objective-C, a method is said to override any method in the class's
	 *  base class, its protocols, or its categories' protocols, that has the same
	 *  selector and is of the same kind (class or instance).
	 *  If no such method exists, the search continues to the class's superclass,
	 *  its protocols, and its categories, and so on. A method from an Objective-C
	 *  implementation is considered to override the same methods as its
	 *  corresponding method in the interface.
	 *  For C++, a virtual member function overrides any virtual member
	 *  function with the same signature that occurs in its base
	 *  classes. With multiple inheritance, a virtual member function can
	 *  override several virtual member functions coming from different
	 *  base classes.
	 *  In all cases, this function determines the immediate overridden
	 *  method, rather than all of the overridden methods. For example, if
	 *  a method is originally declared in a class A, then overridden in B
	 *  (which in inherits from A) and also in C (which inherited from B),
	 *  then the only overridden method returned from this function when
	 *  invoked on C's method will be B's method. The client may then
	 *  invoke this function again, given the previously-found overridden
	 *  methods, to map out the complete method-override set.
	 *  
	 *  @param cursor A cursor representing an Objective-C or C++
	 *  method. This routine will compute the set of methods that this
	 *  method overrides.
	 *  
	 *  @param overridden A pointer whose pointee will be replaced with a
	 *  pointer to an array of cursors, representing the set of overridden
	 *  methods. If there are no overridden methods, the pointee will be
	 *  set to NULL. The pointee must be freed via a call to
	 *  @c clang_disposeOverriddenCursors(). 
	 *   
	 *  @param num_overridden A pointer to the number of overridden
	 *  functions, will be set to the number of overridden functions in the
	 *  array pointed to by @p overridden.  
	 */
	[Import(Clang.dll), LinkName("clang_getOverriddenCursors")] public static extern void GetOverriddenCursors(CXCursor cursor, CXCursor** overridden, c_uint* num_overridden);

	/** Free the set of overridden cursors returned by @c clang_getOverriddenCursors().  
	 */
	[Import(Clang.dll), LinkName("clang_disposeOverriddenCursors")] public static extern void DisposeOverriddenCursors(CXCursor* overridden);

	/** Retrieve the file that is included by the given inclusion directive
	 *  cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getIncludedFile")] public static extern CXFile GetIncludedFile(CXCursor cursor);

	/** Map a source location to the cursor that describes the entity at that
	 *  location in the source code.
	 *  clang_getCursor() maps an arbitrary source location within a translation
	 *  unit down to the most specific cursor that describes the entity at that
	 *  location. For example, given an expression @c x + y, invoking clang_getCursor() with a source location pointing to "x" will return the
	 *  cursor for "x"; similarly for "y". If the cursor points anywhere between
	 *  "x" or "y" (e.g., on the + or the whitespace around it), clang_getCursor()
	 *  will return a cursor referring to the "+" expression.
	 *  
	 *  @returns a cursor representing the entity at the given source location, or
	 *  a NULL cursor if no such entity can be found.
	 */
	[Import(Clang.dll), LinkName("clang_getCursor")] public static extern CXCursor GetCursor(CXTranslationUnit, CXSourceLocation);

	/** Retrieve the physical location of the source constructor referenced
	 *  by the given cursor.
	 *  The location of a declaration is typically the location of the name of that
	 *  declaration, where the name of that declaration would occur if it is
	 *  unnamed, or some keyword that introduces that particular declaration.
	 *  The location of a reference is where that reference occurs within the
	 *  source code.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorLocation")] public static extern CXSourceLocation GetCursorLocation(CXCursor);

	/** Retrieve the physical extent of the source construct referenced by
	 *  the given cursor.
	 *  The extent of a cursor starts with the file/line/column pointing at the
	 *  first character within the source construct that the cursor refers to and
	 *  ends with the last character within that source construct. For a
	 *  declaration, the extent covers the declaration itself. For a reference,
	 *  the extent covers the location of the reference (e.g., where the referenced
	 *  entity was actually used).
	 */
	[Import(Clang.dll), LinkName("clang_getCursorExtent")] public static extern CXSourceRange GetCursorExtent(CXCursor);
}

/** Describes the kind of type
 */
[CRepr, AllowDuplicates] enum CXTypeKind : c_int
{
	/** Represents an invalid type (e.g., where no type is available).
	 */
	Invalid = 0,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Unexposed = 1,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Void = 2,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Bool = 3,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Char_U = 4,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	UChar = 5,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Char16 = 6,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Char32 = 7,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	UShort = 8,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	UInt = 9,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ULong = 10,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ULongLong = 11,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	UInt128 = 12,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Char_S = 13,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	SChar = 14,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	WChar = 15,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Short = 16,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Int = 17,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Long = 18,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	LongLong = 19,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Int128 = 20,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Float = 21,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Double = 22,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	LongDouble = 23,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	NullPtr = 24,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Overload = 25,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Dependent = 26,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCId = 27,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCClass = 28,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCSel = 29,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Float128 = 30,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Half = 31,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Float16 = 32,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ShortAccum = 33,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Accum = 34,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	LongAccum = 35,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	UShortAccum = 36,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	UAccum = 37,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ULongAccum = 38,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	BFloat16 = 39,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Ibm128 = 40,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	FirstBuiltin = Void,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	LastBuiltin = Ibm128,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Complex = 100,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Pointer = 101,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	BlockPointer = 102,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	LValueReference = 103,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	RValueReference = 104,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Record = 105,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Enum = 106,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Typedef = 107,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCInterface = 108,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ObjCObjectPointer = 109,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	FunctionNoProto = 110,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	FunctionProto = 111,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	ConstantArray = 112,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Vector = 113,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	IncompleteArray = 114,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	VariableArray = 115,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	DependentSizedArray = 116,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	MemberPointer = 117,

	/** A type whose specific kind is not exposed via this
	 *  interface.
	 */
	Auto = 118,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	Elaborated = 119,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	Pipe = 120,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dRO = 121,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dArrayRO = 122,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dBufferRO = 123,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dRO = 124,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayRO = 125,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dDepthRO = 126,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayDepthRO = 127,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dMSAARO = 128,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayMSAARO = 129,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dMSAADepthRO = 130,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayMSAADepthRO = 131,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage3dRO = 132,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dWO = 133,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dArrayWO = 134,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dBufferWO = 135,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dWO = 136,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayWO = 137,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dDepthWO = 138,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayDepthWO = 139,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dMSAAWO = 140,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayMSAAWO = 141,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dMSAADepthWO = 142,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayMSAADepthWO = 143,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage3dWO = 144,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dRW = 145,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dArrayRW = 146,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage1dBufferRW = 147,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dRW = 148,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayRW = 149,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dDepthRW = 150,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayDepthRW = 151,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dMSAARW = 152,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayMSAARW = 153,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dMSAADepthRW = 154,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage2dArrayMSAADepthRW = 155,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLImage3dRW = 156,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLSampler = 157,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLEvent = 158,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLQueue = 159,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLReserveID = 160,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	ObjCObject = 161,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	ObjCTypeParam = 162,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	Attributed = 163,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCMcePayload = 164,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImePayload = 165,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCRefPayload = 166,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCSicPayload = 167,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCMceResult = 168,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeResult = 169,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCRefResult = 170,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCSicResult = 171,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeResultSingleReferenceStreamout = 172,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeResultDualReferenceStreamout = 173,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeSingleReferenceStreamin = 174,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeDualReferenceStreamin = 175,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeResultSingleRefStreamout = 172,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeResultDualRefStreamout = 173,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeSingleRefStreamin = 174,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	OCLIntelSubgroupAVCImeDualRefStreamin = 175,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	ExtVector = 176,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	Atomic = 177,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	BTFTagAttributed = 178,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	HLSLResource = 179,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	HLSLAttributedResource = 180,

	/** Represents a type that was referred to using an elaborated type keyword.
	 *  E.g., struct S, or via a qualified name, e.g., N::M::type, or both.
	 */
	HLSLInlineSpirv = 181,
}

/** Describes the calling convention of a function type
 */
[CRepr, AllowDuplicates] enum CXCallingConv : c_int
{
	Default = 0,
	C = 1,
	X86StdCall = 2,
	X86FastCall = 3,
	X86ThisCall = 4,
	X86Pascal = 5,
	AAPCS = 6,
	AAPCS_VFP = 7,
	X86RegCall = 8,
	IntelOclBicc = 9,
	Win64 = 10,
	X86_64Win64 = Win64,
	X86_64SysV = 11,
	X86VectorCall = 12,
	Swift = 13,
	PreserveMost = 14,
	PreserveAll = 15,
	AArch64VectorCall = 16,
	SwiftAsync = 17,
	AArch64SVEPCS = 18,
	M68kRTD = 19,
	PreserveNone = 20,
	RISCVVectorCall = 21,
	RISCVVLSCall_32 = 22,
	RISCVVLSCall_64 = 23,
	RISCVVLSCall_128 = 24,
	RISCVVLSCall_256 = 25,
	RISCVVLSCall_512 = 26,
	RISCVVLSCall_1024 = 27,
	RISCVVLSCall_2048 = 28,
	RISCVVLSCall_4096 = 29,
	RISCVVLSCall_8192 = 30,
	RISCVVLSCall_16384 = 31,
	RISCVVLSCall_32768 = 32,
	RISCVVLSCall_65536 = 33,
	Invalid = 100,
	Unexposed = 200,
}

/** The type of an element in the abstract syntax tree.
 *  
 */
[CRepr] struct CXType
{
	public CXTypeKind kind;
	public void*[2] data;
}

extension Clang
{
	/** Retrieve the type of a CXCursor (if any).
	 */
	[Import(Clang.dll), LinkName("clang_getCursorType")] public static extern CXType GetCursorType(CXCursor C);

	/** Pretty-print the underlying type using the rules of the
	 *  language of the translation unit from which it came.
	 *  If the type is invalid, an empty string is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getTypeSpelling")] public static extern CXString GetTypeSpelling(CXType CT);

	/** Retrieve the underlying type of a typedef declaration.
	 *  If the cursor does not reference a typedef declaration, an invalid type is
	 *  returned.
	 */
	[Import(Clang.dll), LinkName("clang_getTypedefDeclUnderlyingType")] public static extern CXType GetTypedefDeclUnderlyingType(CXCursor C);

	/** Retrieve the integer type of an enum declaration.
	 *  If the cursor does not reference an enum declaration, an invalid type is
	 *  returned.
	 */
	[Import(Clang.dll), LinkName("clang_getEnumDeclIntegerType")] public static extern CXType GetEnumDeclIntegerType(CXCursor C);

	/** Retrieve the integer value of an enum constant declaration as a signed
	 *  long long.
	 *  If the cursor does not reference an enum constant declaration, LLONG_MIN is
	 *  returned. Since this is also potentially a valid constant value, the kind of
	 *  the cursor must be verified before calling this function.
	 */
	[Import(Clang.dll), LinkName("clang_getEnumConstantDeclValue")] public static extern c_longlong GetEnumConstantDeclValue(CXCursor C);

	/** Retrieve the integer value of an enum constant declaration as an unsigned
	 *  long long.
	 *  If the cursor does not reference an enum constant declaration, ULLONG_MAX is
	 *  returned. Since this is also potentially a valid constant value, the kind of
	 *  the cursor must be verified before calling this function.
	 */
	[Import(Clang.dll), LinkName("clang_getEnumConstantDeclUnsignedValue")] public static extern c_ulonglong GetEnumConstantDeclUnsignedValue(CXCursor C);

	/** Returns non-zero if the cursor specifies a Record member that is a bit-field.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isBitField")] public static extern c_uint Cursor_IsBitField(CXCursor C);

	/** Retrieve the bit width of a bit-field declaration as an integer.
	 *  If the cursor does not reference a bit-field, or if the bit-field's width
	 *  expression cannot be evaluated, -1 is returned.
	 *  For example:
	 *  
	 *  ```
	 *  if (clang_Cursor_isBitField(Cursor)) {
	 *  int Width = clang_getFieldDeclBitWidth(Cursor);
	 *  if (Width != -1) {
	 *    // The bit-field width is not value-dependent.
	 *  }
	 *  }
	 *  ```
	 *  
	 */
	[Import(Clang.dll), LinkName("clang_getFieldDeclBitWidth")] public static extern c_int GetFieldDeclBitWidth(CXCursor C);

	/** Retrieve the number of non-variadic arguments associated with a given
	 *  cursor.
	 *  The number of arguments can be determined for calls as well as for
	 *  declarations of functions or methods. For other cursors -1 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getNumArguments")] public static extern c_int Cursor_GetNumArguments(CXCursor C);

	/** Retrieve the argument cursor of a function or method.
	 *  The argument cursor can be determined for calls as well as for declarations
	 *  of functions or methods. For other cursors and for invalid indices, an
	 *  invalid cursor is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getArgument")] public static extern CXCursor Cursor_GetArgument(CXCursor C, c_uint i);
}

/** Describes the kind of a template argument.
 *  See the definition of llvm::clang::TemplateArgument::ArgKind for full
 *  element descriptions.
 */
[CRepr, AllowDuplicates] enum CXTemplateArgumentKind : c_int
{
	Null = 0,
	Type = 1,
	Declaration = 2,
	NullPtr = 3,
	Integral = 4,
	Template = 5,
	TemplateExpansion = 6,
	Expression = 7,
	Pack = 8,
	Invalid = 9,
}

extension Clang
{
	/** Returns the number of template args of a function, struct, or class decl
	 *  representing a template specialization.
	 *  If the argument cursor cannot be converted into a template function
	 *  declaration, -1 is returned.
	 *  For example, for the following declaration and specialization:
	 *  template 
	 *  <typename
	 *  T, int kInt, bool kBool>
	 *  void foo() { ... }
	 *  template 
	 *  <
	 *  >
	 *  void foo
	 *  <float
	 *  , -7, true>();
	 *  The value 3 would be returned from this call.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getNumTemplateArguments")] public static extern c_int Cursor_GetNumTemplateArguments(CXCursor C);

	/** Retrieve the kind of the I'th template argument of the CXCursor C.
	 *  If the argument CXCursor does not represent a FunctionDecl, StructDecl, or
	 *  ClassTemplatePartialSpecialization, an invalid template argument kind is
	 *  returned.
	 *  For example, for the following declaration and specialization:
	 *  template 
	 *  <typename
	 *  T, int kInt, bool kBool>
	 *  void foo() { ... }
	 *  template 
	 *  <
	 *  >
	 *  void foo
	 *  <float
	 *  , -7, true>();
	 *  For I = 0, 1, and 2, Type, Integral, and Integral will be returned,
	 *  respectively.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getTemplateArgumentKind")] public static extern CXTemplateArgumentKind Cursor_GetTemplateArgumentKind(CXCursor C, c_uint I);

	/** Retrieve a CXType representing the type of a TemplateArgument of a
	 *  function decl representing a template specialization.
	 *  If the argument CXCursor does not represent a FunctionDecl, StructDecl,
	 *  ClassDecl or ClassTemplatePartialSpecialization whose I'th template argument
	 *  has a kind of CXTemplateArgKind_Integral, an invalid type is returned.
	 *  For example, for the following declaration and specialization:
	 *  template 
	 *  <typename
	 *  T, int kInt, bool kBool>
	 *  void foo() { ... }
	 *  template 
	 *  <
	 *  >
	 *  void foo
	 *  <float
	 *  , -7, true>();
	 *  If called with I = 0, "float", will be returned.
	 *  Invalid types will be returned for I == 1 or 2.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getTemplateArgumentType")] public static extern CXType Cursor_GetTemplateArgumentType(CXCursor C, c_uint I);

	/** Retrieve the value of an Integral TemplateArgument (of a function
	 *  decl representing a template specialization) as a signed long long.
	 *  It is undefined to call this function on a CXCursor that does not represent a
	 *  FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization
	 *  whose I'th template argument is not an integral value.
	 *  For example, for the following declaration and specialization:
	 *  template 
	 *  <typename
	 *  T, int kInt, bool kBool>
	 *  void foo() { ... }
	 *  template 
	 *  <
	 *  >
	 *  void foo
	 *  <float
	 *  , -7, true>();
	 *  If called with I = 1 or 2, -7 or true will be returned, respectively.
	 *  For I == 0, this function's behavior is undefined.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getTemplateArgumentValue")] public static extern c_longlong Cursor_GetTemplateArgumentValue(CXCursor C, c_uint I);

	/** Retrieve the value of an Integral TemplateArgument (of a function
	 *  decl representing a template specialization) as an unsigned long long.
	 *  It is undefined to call this function on a CXCursor that does not represent a
	 *  FunctionDecl, StructDecl, ClassDecl or ClassTemplatePartialSpecialization or
	 *  whose I'th template argument is not an integral value.
	 *  For example, for the following declaration and specialization:
	 *  template 
	 *  <typename
	 *  T, int kInt, bool kBool>
	 *  void foo() { ... }
	 *  template 
	 *  <
	 *  >
	 *  void foo
	 *  <float
	 *  , 2147483649, true>();
	 *  If called with I = 1 or 2, 2147483649 or true will be returned, respectively.
	 *  For I == 0, this function's behavior is undefined.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getTemplateArgumentUnsignedValue")] public static extern c_ulonglong Cursor_GetTemplateArgumentUnsignedValue(CXCursor C, c_uint I);

	/** Determine whether two CXTypes represent the same type.
	 *  
	 *  @returns non-zero if the CXTypes represent the same type and
	 *  zero otherwise.
	 */
	[Import(Clang.dll), LinkName("clang_equalTypes")] public static extern c_uint EqualTypes(CXType A, CXType B);

	/** Return the canonical type for a CXType.
	 *  Clang's type system explicitly models typedefs and all the ways
	 *  a specific type can be represented.  The canonical type is the underlying
	 *  type with all the "sugar" removed.  For example, if 'T' is a typedef
	 *  for 'int', the canonical type for 'T' would be 'int'.
	 */
	[Import(Clang.dll), LinkName("clang_getCanonicalType")] public static extern CXType GetCanonicalType(CXType T);

	/** Determine whether a CXType has the "const" qualifier set,
	 *  without looking through typedefs that may have added "const" at a
	 *  different level.
	 */
	[Import(Clang.dll), LinkName("clang_isConstQualifiedType")] public static extern c_uint IsConstQualifiedType(CXType T);

	/** Determine whether a  CXCursor that is a macro, is
	 *  function like.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isMacroFunctionLike")] public static extern c_uint Cursor_IsMacroFunctionLike(CXCursor C);

	/** Determine whether a  CXCursor that is a macro, is a
	 *  builtin one.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isMacroBuiltin")] public static extern c_uint Cursor_IsMacroBuiltin(CXCursor C);

	/** Determine whether a  CXCursor that is a function declaration, is an
	 *  inline declaration.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isFunctionInlined")] public static extern c_uint Cursor_IsFunctionInlined(CXCursor C);

	/** Determine whether a CXType has the "volatile" qualifier set,
	 *  without looking through typedefs that may have added "volatile" at
	 *  a different level.
	 */
	[Import(Clang.dll), LinkName("clang_isVolatileQualifiedType")] public static extern c_uint IsVolatileQualifiedType(CXType T);

	/** Determine whether a CXType has the "restrict" qualifier set,
	 *  without looking through typedefs that may have added "restrict" at a
	 *  different level.
	 */
	[Import(Clang.dll), LinkName("clang_isRestrictQualifiedType")] public static extern c_uint IsRestrictQualifiedType(CXType T);

	/** Returns the address space of the given type.
	 */
	[Import(Clang.dll), LinkName("clang_getAddressSpace")] public static extern c_uint GetAddressSpace(CXType T);

	/** Returns the typedef name of the given type.
	 */
	[Import(Clang.dll), LinkName("clang_getTypedefName")] public static extern CXString GetTypedefName(CXType CT);

	/** For pointer types, returns the type of the pointee.
	 */
	[Import(Clang.dll), LinkName("clang_getPointeeType")] public static extern CXType GetPointeeType(CXType T);

	/** Retrieve the unqualified variant of the given type, removing as
	 *  little sugar as possible.
	 *  For example, given the following series of typedefs:
	 *  
	 *  ```
	 *  typedef int Integer;
	 *  typedef const Integer CInteger;
	 *  typedef CInteger DifferenceType;
	 *  ```
	 *  Executing @c clang_getUnqualifiedType() on a  @c CXType that represents @c DifferenceType, will desugar to a type representing @c Integer, that has no qualifiers. 
	 *  And, executing @c clang_getUnqualifiedType() on the type of the first argument of the following function declaration:
	 *  
	 *  ```
	 *  void foo(const int);
	 *  ```
	 *  Will return a type representing @c int, removing the  @c const qualifier. 
	 *  Sugar over array types is not desugared.
	 *  A type can be checked for qualifiers with @c clang_isConstQualifiedType(),  @c clang_isVolatileQualifiedType() and  @c clang_isRestrictQualifiedType(). 
	 *  A type that resulted from a call to  @c clang_getUnqualifiedType will return  @c false for all of the above calls. 
	 */
	[Import(Clang.dll), LinkName("clang_getUnqualifiedType")] public static extern CXType GetUnqualifiedType(CXType CT);

	/** For reference types (e.g., "const int&"), returns the type that the
	 *  reference refers to (e.g "const int").
	 *  Otherwise, returns the type itself.
	 *  A type that has kind @c CXType_LValueReference or @c CXType_RValueReference is a reference type. 
	 */
	[Import(Clang.dll), LinkName("clang_getNonReferenceType")] public static extern CXType GetNonReferenceType(CXType CT);

	/** Return the cursor for the declaration of the given type.
	 */
	[Import(Clang.dll), LinkName("clang_getTypeDeclaration")] public static extern CXCursor GetTypeDeclaration(CXType T);

	/** Returns the Objective-C type encoding for the specified declaration.
	 */
	[Import(Clang.dll), LinkName("clang_getDeclObjCTypeEncoding")] public static extern CXString GetDeclObjCTypeEncoding(CXCursor C);

	/** Returns the Objective-C type encoding for the specified CXType.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getObjCEncoding")] public static extern CXString Type_GetObjCEncoding(CXType type);

	/** Retrieve the spelling of a given CXTypeKind.
	 */
	[Import(Clang.dll), LinkName("clang_getTypeKindSpelling")] public static extern CXString GetTypeKindSpelling(CXTypeKind K);

	/** Retrieve the calling convention associated with a function type.
	 *  If a non-function type is passed in, CXCallingConv_Invalid is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getFunctionTypeCallingConv")] public static extern CXCallingConv GetFunctionTypeCallingConv(CXType T);

	/** Retrieve the return type associated with a function type.
	 *  If a non-function type is passed in, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getResultType")] public static extern CXType GetResultType(CXType T);

	/** Retrieve the exception specification type associated with a function type.
	 *  This is a value of type CXCursor_ExceptionSpecificationKind.
	 *  If a non-function type is passed in, an error code of -1 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getExceptionSpecificationType")] public static extern c_int GetExceptionSpecificationType(CXType T);

	/** Retrieve the number of non-variadic parameters associated with a
	 *  function type.
	 *  If a non-function type is passed in, -1 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getNumArgTypes")] public static extern c_int GetNumArgTypes(CXType T);

	/** Retrieve the type of a parameter of a function type.
	 *  If a non-function type is passed in or the function does not have enough
	 *  parameters, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getArgType")] public static extern CXType GetArgType(CXType T, c_uint i);

	/** Retrieves the base type of the ObjCObjectType.
	 *  If the type is not an ObjC object, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getObjCObjectBaseType")] public static extern CXType Type_GetObjCObjectBaseType(CXType T);

	/** Retrieve the number of protocol references associated with an ObjC object/id.
	 *  If the type is not an ObjC object, 0 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getNumObjCProtocolRefs")] public static extern c_uint Type_GetNumObjCProtocolRefs(CXType T);

	/** Retrieve the decl for a protocol reference for an ObjC object/id.
	 *  If the type is not an ObjC object or there are not enough protocol
	 *  references, an invalid cursor is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getObjCProtocolDecl")] public static extern CXCursor Type_GetObjCProtocolDecl(CXType T, c_uint i);

	/** Retrieve the number of type arguments associated with an ObjC object.
	 *  If the type is not an ObjC object, 0 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getNumObjCTypeArgs")] public static extern c_uint Type_GetNumObjCTypeArgs(CXType T);

	/** Retrieve a type argument associated with an ObjC object.
	 *  If the type is not an ObjC or the index is not valid,
	 *  an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getObjCTypeArg")] public static extern CXType Type_GetObjCTypeArg(CXType T, c_uint i);

	/** Return 1 if the CXType is a variadic function type, and 0 otherwise.
	 */
	[Import(Clang.dll), LinkName("clang_isFunctionTypeVariadic")] public static extern c_uint IsFunctionTypeVariadic(CXType T);

	/** Retrieve the return type associated with a given cursor.
	 *  This only returns a valid type if the cursor refers to a function or method.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorResultType")] public static extern CXType GetCursorResultType(CXCursor C);

	/** Retrieve the exception specification type associated with a given cursor.
	 *  This is a value of type CXCursor_ExceptionSpecificationKind.
	 *  This only returns a valid result if the cursor refers to a function or
	 *  method.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorExceptionSpecificationType")] public static extern c_int GetCursorExceptionSpecificationType(CXCursor C);

	/** Return 1 if the CXType is a POD (plain old data) type, and 0
	 *  otherwise.
	 */
	[Import(Clang.dll), LinkName("clang_isPODType")] public static extern c_uint IsPODType(CXType T);

	/** Return the element type of an array, complex, or vector type.
	 *  If a type is passed in that is not an array, complex, or vector type,
	 *  an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getElementType")] public static extern CXType GetElementType(CXType T);

	/** Return the number of elements of an array or vector type.
	 *  If a type is passed in that is not an array or vector type,
	 *  -1 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getNumElements")] public static extern c_longlong GetNumElements(CXType T);

	/** Return the element type of an array type.
	 *  If a non-array type is passed in, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getArrayElementType")] public static extern CXType GetArrayElementType(CXType T);

	/** Return the array size of a constant array.
	 *  If a non-array type is passed in, -1 is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getArraySize")] public static extern c_longlong GetArraySize(CXType T);

	/** Retrieve the type named by the qualified-id.
	 *  If a non-elaborated type is passed in, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getNamedType")] public static extern CXType Type_GetNamedType(CXType T);

	/** Determine if a typedef is 'transparent' tag.
	 *  A typedef is considered 'transparent' if it shares a name and spelling
	 *  location with its underlying tag type, as is the case with the NS_ENUM macro.
	 *  
	 *  @returns non-zero if transparent and zero otherwise.
	 */
	[Import(Clang.dll), LinkName("clang_Type_isTransparentTagTypedef")] public static extern c_uint Type_IsTransparentTagTypedef(CXType T);
}

[CRepr, AllowDuplicates] enum CXTypeNullabilityKind : c_int
{
	/** Values of this type can never be null.
	 */
	NonNull = 0,

	/** Values of this type can be null.
	 */
	Nullable = 1,

	/** Whether values of this type can be null is (explicitly)
	 *  unspecified. This captures a (fairly rare) case where we
	 *  can't conclude anything about the nullability of the type even
	 *  though it has been considered.
	 */
	Unspecified = 2,

	/** Nullability is not applicable to this type.
	 */
	Invalid = 3,

	/** Generally behaves like Nullable, except when used in a block parameter that
	 *  was imported into a swift async method. There, swift will assume that the
	 *  parameter can get null even if no error occurred. _Nullable parameters are
	 *  assumed to only get null on error.
	 */
	NullableResult = 4,
}

extension Clang
{
	/** Retrieve the nullability kind of a pointer type.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getNullability")] public static extern CXTypeNullabilityKind Type_GetNullability(CXType T);
}

/** List the possible error codes for @c clang_Type_getSizeOf,  @c clang_Type_getAlignOf,  @c clang_Type_getOffsetOf,  @c clang_Cursor_getOffsetOf, and  @c clang_getOffsetOfBase. 
 *  A value of this enumeration type can be returned if the target type is not a valid argument to sizeof, alignof or offsetof.
 */
[CRepr, AllowDuplicates] enum CXTypeLayoutError : c_int
{
	/** Type is of kind CXType_Invalid.
	 */
	Invalid =  - 1,

	/** The type is an incomplete Type.
	 */
	Incomplete =  - 2,

	/** The type is a dependent Type.
	 */
	Dependent =  - 3,

	/** The type is not a constant size type.
	 */
	NotConstantSize =  - 4,

	/** The Field name is not valid for this record.
	 */
	InvalidFieldName =  - 5,

	/** The type is undeduced.
	 */
	Undeduced =  - 6,
}

extension Clang
{
	/** Return the alignment of a type in bytes as per C++[expr.alignof]
	 *  standard.
	 *  If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
	 *  If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
	 *  is returned.
	 *  If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
	 *  returned.
	 *  If the type declaration is not a constant size type,
	 *  CXTypeLayoutError_NotConstantSize is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getAlignOf")] public static extern c_longlong Type_GetAlignOf(CXType T);

	/** Return the class type of an member pointer type.
	 *  If a non-member-pointer type is passed in, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getClassType")] public static extern CXType Type_GetClassType(CXType T);

	/** Return the size of a type in bytes as per C++[expr.sizeof] standard.
	 *  If the type declaration is invalid, CXTypeLayoutError_Invalid is returned.
	 *  If the type declaration is an incomplete type, CXTypeLayoutError_Incomplete
	 *  is returned.
	 *  If the type declaration is a dependent type, CXTypeLayoutError_Dependent is
	 *  returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getSizeOf")] public static extern c_longlong Type_GetSizeOf(CXType T);

	/** Return the offset of a field named S in a record of type T in bits
	 *  as it would be returned by __offsetof__ as per C++11[18.2p4]
	 *  If the cursor is not a record field declaration, CXTypeLayoutError_Invalid
	 *  is returned.
	 *  If the field's type declaration is an incomplete type,
	 *  CXTypeLayoutError_Incomplete is returned.
	 *  If the field's type declaration is a dependent type,
	 *  CXTypeLayoutError_Dependent is returned.
	 *  If the field's name S is not found,
	 *  CXTypeLayoutError_InvalidFieldName is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getOffsetOf")] public static extern c_longlong Type_GetOffsetOf(CXType T, c_char* S);

	/** Return the type that was modified by this attributed type.
	 *  If the type is not an attributed type, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getModifiedType")] public static extern CXType Type_GetModifiedType(CXType T);

	/** Gets the type contained by this atomic type.
	 *  If a non-atomic type is passed in, an invalid type is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getValueType")] public static extern CXType Type_GetValueType(CXType CT);

	/** Return the offset of the field represented by the Cursor.
	 *  If the cursor is not a field declaration, -1 is returned.
	 *  If the cursor semantic parent is not a record field declaration,
	 *  CXTypeLayoutError_Invalid is returned.
	 *  If the field's type declaration is an incomplete type,
	 *  CXTypeLayoutError_Incomplete is returned.
	 *  If the field's type declaration is a dependent type,
	 *  CXTypeLayoutError_Dependent is returned.
	 *  If the field's name S is not found,
	 *  CXTypeLayoutError_InvalidFieldName is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getOffsetOfField")] public static extern c_longlong Cursor_GetOffsetOfField(CXCursor C);

	/** Determine whether the given cursor represents an anonymous
	 *  tag or namespace
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isAnonymous")] public static extern c_uint Cursor_IsAnonymous(CXCursor C);

	/** Determine whether the given cursor represents an anonymous record
	 *  declaration.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isAnonymousRecordDecl")] public static extern c_uint Cursor_IsAnonymousRecordDecl(CXCursor C);

	/** Determine whether the given cursor represents an inline namespace
	 *  declaration.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isInlineNamespace")] public static extern c_uint Cursor_IsInlineNamespace(CXCursor C);
}

[CRepr, AllowDuplicates] enum CXRefQualifierKind : c_int
{
	/** No ref-qualifier was provided. 
	 */
	None = 0,

	/** An lvalue ref-qualifier was provided (@c &).  
	 */
	LValue = 1,

	/** An rvalue ref-qualifier was provided (@c &&).  
	 */
	RValue = 2,
}

extension Clang
{
	/** Returns the number of template arguments for given template
	 *  specialization, or -1 if type @c T is not a template specialization. 
	 */
	[Import(Clang.dll), LinkName("clang_Type_getNumTemplateArguments")] public static extern c_int Type_GetNumTemplateArguments(CXType T);

	/** Returns the type template argument of a template class specialization
	 *  at given index.
	 *  This function only returns template type arguments and does not handle
	 *  template template arguments or variadic packs.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getTemplateArgumentAsType")] public static extern CXType Type_GetTemplateArgumentAsType(CXType T, c_uint i);

	/** Retrieve the ref-qualifier kind of a function or method.
	 *  The ref-qualifier is returned for C++ functions or methods. For other types
	 *  or non-C++ declarations, CXRefQualifier_None is returned.
	 */
	[Import(Clang.dll), LinkName("clang_Type_getCXXRefQualifier")] public static extern CXRefQualifierKind Type_GetCXXRefQualifier(CXType T);

	/** Returns 1 if the base class specified by the cursor with kind
	 *  CX_CXXBaseSpecifier is virtual.
	 */
	[Import(Clang.dll), LinkName("clang_isVirtualBase")] public static extern c_uint IsVirtualBase(CXCursor);

	/** Returns the offset in bits of a CX_CXXBaseSpecifier relative to the parent
	 *  class.
	 *  Returns a small negative number if the offset cannot be computed. See
	 *  CXTypeLayoutError for error codes.
	 */
	[Import(Clang.dll), LinkName("clang_getOffsetOfBase")] public static extern c_longlong GetOffsetOfBase(CXCursor Parent, CXCursor Base);
}

/** Represents the C++ access control level to a base class for a
 *  cursor with kind CX_CXXBaseSpecifier.
 */
[CRepr, AllowDuplicates] enum CX_CXXAccessSpecifier : c_int
{
	InvalidAccessSpecifier = 0,
	Public = 1,
	Protected = 2,
	Private = 3,
}

extension Clang
{
	/** Returns the access control level for the referenced object.
	 *  If the cursor refers to a C++ declaration, its access control level within
	 *  its parent scope is returned. Otherwise, if the cursor refers to a base
	 *  specifier or access specifier, the specifier itself is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getCXXAccessSpecifier")] public static extern CX_CXXAccessSpecifier GetCXXAccessSpecifier(CXCursor);
}

/** Represents the storage classes as declared in the source. CX_SC_Invalid
 *  was added for the case that the passed cursor in not a declaration.
 */
[CRepr, AllowDuplicates] enum CX_StorageClass : c_int
{
	C_Invalid = 0,
	C_None = 1,
	C_Extern = 2,
	C_Static = 3,
	C_PrivateExtern = 4,
	C_OpenCLWorkGroupLocal = 5,
	C_Auto = 6,
	C_Register = 7,
}

/** Represents a specific kind of binary operator which can appear at a cursor.
 */
[CRepr, AllowDuplicates] enum CX_BinaryOperatorKind : c_int
{
	O_Invalid = 0,
	O_PtrMemD = 1,
	O_PtrMemI = 2,
	O_Mul = 3,
	O_Div = 4,
	O_Rem = 5,
	O_Add = 6,
	O_Sub = 7,
	O_Shl = 8,
	O_Shr = 9,
	O_Cmp = 10,
	O_LT = 11,
	O_GT = 12,
	O_LE = 13,
	O_GE = 14,
	O_EQ = 15,
	O_NE = 16,
	O_And = 17,
	O_Xor = 18,
	O_Or = 19,
	O_LAnd = 20,
	O_LOr = 21,
	O_Assign = 22,
	O_MulAssign = 23,
	O_DivAssign = 24,
	O_RemAssign = 25,
	O_AddAssign = 26,
	O_SubAssign = 27,
	O_ShlAssign = 28,
	O_ShrAssign = 29,
	O_AndAssign = 30,
	O_XorAssign = 31,
	O_OrAssign = 32,
	O_Comma = 33,
	O_LAST = O_Comma,
}

extension Clang
{
	/** 
	 *  @brief Returns the operator code for the binary operator.
	 *  
	 *  @deprecated : use clang_getCursorBinaryOperatorKind instead.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getBinaryOpcode")] public static extern CX_BinaryOperatorKind Cursor_GetBinaryOpcode(CXCursor C);

	/** 
	 *  @brief Returns a string containing the spelling of the binary operator.
	 *  
	 *  @deprecated : use clang_getBinaryOperatorKindSpelling instead
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getBinaryOpcodeStr")] public static extern CXString Cursor_GetBinaryOpcodeStr(CX_BinaryOperatorKind Op);

	/** Returns the storage class for a function or variable declaration.
	 *  If the passed in Cursor is not a function or variable declaration,
	 *  CX_SC_Invalid is returned else the storage class.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getStorageClass")] public static extern CX_StorageClass Cursor_GetStorageClass(CXCursor);

	/** Determine the number of overloaded declarations referenced by a
	 *  @c CXCursor_OverloadedDeclRef cursor. 
	 *  
	 *  @param cursor The cursor whose overloaded declarations are being queried.
	 *  
	 *  @returns The number of overloaded declarations referenced by @c cursor. If it is not a @c CXCursor_OverloadedDeclRef cursor, returns 0. 
	 */
	[Import(Clang.dll), LinkName("clang_getNumOverloadedDecls")] public static extern c_uint GetNumOverloadedDecls(CXCursor cursor);

	/** Retrieve a cursor for one of the overloaded declarations referenced
	 *  by a @c CXCursor_OverloadedDeclRef cursor. 
	 *  
	 *  @param cursor The cursor whose overloaded declarations are being queried.
	 *  
	 *  @param index The zero-based index into the set of overloaded declarations in
	 *  the cursor.
	 *  
	 *  @returns A cursor representing the declaration referenced by the given
	 *  @c cursor at the specified  @c index. If the cursor does not have an associated set of overloaded declarations, or if the index is out of bounds,
	 *  returns @c clang_getNullCursor();  
	 */
	[Import(Clang.dll), LinkName("clang_getOverloadedDecl")] public static extern CXCursor GetOverloadedDecl(CXCursor cursor, c_uint index);

	/** For cursors representing an iboutletcollection attribute,
	 *  this function returns the collection element type.
	 *  
	 */
	[Import(Clang.dll), LinkName("clang_getIBOutletCollectionType")] public static extern CXType GetIBOutletCollectionType(CXCursor);
}

/** Describes how the traversal of the children of a particular
 *  cursor should proceed after visiting a particular child cursor.
 *  A value of this enumeration type should be returned by each
 *  @c CXCursorVisitor to indicate how clang_visitChildren() proceed. 
 */
[CRepr, AllowDuplicates] enum CXChildVisitResult : c_int
{
	/** Terminates the cursor traversal.
	 */
	Break = 0,

	/** Continues the cursor traversal with the next sibling of
	 *  the cursor just visited, without visiting its children.
	 */
	Continue = 1,

	/** Recursively traverse the children of this cursor, using
	 *  the same visitor and client data.
	 */
	Recurse = 2,
}

/** Visitor invoked for each cursor found by a traversal.
 *  This visitor function will be invoked for each cursor found by
 *  clang_visitCursorChildren(). Its first argument is the cursor being
 *  visited, its second argument is the parent visitor for that cursor,
 *  and its third argument is the client data provided to
 *  clang_visitCursorChildren().
 *  The visitor should return one of the @c CXChildVisitResult values to direct clang_visitCursorChildren().
 */
function CXChildVisitResult CXCursorVisitor(CXCursor cursor, CXCursor parent, CXClientData client_data);

extension Clang
{
	/** Visit the children of a particular cursor.
	 *  This function visits all the direct children of the given cursor,
	 *  invoking the given @p visitor function with the cursors of each visited child. The traversal may be recursive, if the visitor returns
	 *  @c CXChildVisit_Recurse. The traversal may also be ended prematurely, if the visitor returns @c CXChildVisit_Break. 
	 *   
	 *  @param parent the cursor whose child may be visited. All kinds of
	 *  cursors can be visited, including invalid cursors (which, by
	 *  definition, have no children).
	 *  
	 *  @param visitor the visitor function that will be invoked for each
	 *  child of @p parent. 
	 *   
	 *  @param client_data pointer data supplied by the client, which will
	 *  be passed to the visitor each time it is invoked.
	 *  
	 *  @returns a non-zero value if the traversal was terminated
	 *  prematurely by the visitor returning @c CXChildVisit_Break.  
	 */
	[Import(Clang.dll), LinkName("clang_visitChildren")] public static extern c_uint VisitChildren(CXCursor parent, CXCursorVisitor visitor, CXClientData client_data);
}

struct _CXChildVisitResult;
typealias CXCursorVisitorBlock = _CXChildVisitResult*;

extension Clang
{
	/** Visits the children of a cursor using the specified block.  Behaves
	 *  identically to clang_visitChildren() in all other respects.
	 */
	[Import(Clang.dll), LinkName("clang_visitChildrenWithBlock")] public static extern c_uint VisitChildrenWithBlock(CXCursor parent, CXCursorVisitorBlock block);

	/** Retrieve a Unified Symbol Resolution (USR) for the entity referenced
	 *  by the given cursor.
	 *  A Unified Symbol Resolution (USR) is a string that identifies a particular
	 *  entity (function, class, variable, etc.) within a program. USRs can be
	 *  compared across translation units to determine, e.g., when references in
	 *  one translation refer to an entity defined in another translation unit.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorUSR")] public static extern CXString GetCursorUSR(CXCursor);

	/** Construct a USR for a specified Objective-C class.
	 */
	[Import(Clang.dll), LinkName("clang_constructUSR_ObjCClass")] public static extern CXString ConstructUSR_ObjCClass(c_char* class_name);

	/** Construct a USR for a specified Objective-C category.
	 */
	[Import(Clang.dll), LinkName("clang_constructUSR_ObjCCategory")] public static extern CXString ConstructUSR_ObjCCategory(c_char* class_name, c_char* category_name);

	/** Construct a USR for a specified Objective-C protocol.
	 */
	[Import(Clang.dll), LinkName("clang_constructUSR_ObjCProtocol")] public static extern CXString ConstructUSR_ObjCProtocol(c_char* protocol_name);

	/** Construct a USR for a specified Objective-C instance variable and
	 *  the USR for its containing class.
	 */
	[Import(Clang.dll), LinkName("clang_constructUSR_ObjCIvar")] public static extern CXString ConstructUSR_ObjCIvar(c_char* name, CXString classUSR);

	/** Construct a USR for a specified Objective-C method and
	 *  the USR for its containing class.
	 */
	[Import(Clang.dll), LinkName("clang_constructUSR_ObjCMethod")] public static extern CXString ConstructUSR_ObjCMethod(c_char* name, c_uint isInstanceMethod, CXString classUSR);

	/** Construct a USR for a specified Objective-C property and the USR
	 *  for its containing class.
	 */
	[Import(Clang.dll), LinkName("clang_constructUSR_ObjCProperty")] public static extern CXString ConstructUSR_ObjCProperty(c_char* property, CXString classUSR);

	/** Retrieve a name for the entity referenced by this cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorSpelling")] public static extern CXString GetCursorSpelling(CXCursor);

	/** Retrieve a range for a piece that forms the cursors spelling name.
	 *  Most of the times there is only one range for the complete spelling but for
	 *  Objective-C methods and Objective-C message expressions, there are multiple
	 *  pieces for each selector identifier.
	 *  
	 *  @param pieceIndex the index of the spelling name piece. If this is greater
	 *  than the actual number of pieces, it will return a NULL (invalid) range.
	 *  
	 *  @param options Reserved.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getSpellingNameRange")] public static extern CXSourceRange Cursor_GetSpellingNameRange(CXCursor, c_uint pieceIndex, c_uint options);
}

/** Opaque pointer representing a policy that controls pretty printing
 *  for @c clang_getCursorPrettyPrinted.  
 */
class CXPrintingPolicy { private this() {} }

/** Properties for the printing policy.
 *  See @c clang::PrintingPolicy for more information. 
 */
[CRepr, AllowDuplicates] enum CXPrintingPolicyProperty : c_int
{
	Indentation = 0,
	SuppressSpecifiers = 1,
	SuppressTagKeyword = 2,
	IncludeTagDefinition = 3,
	SuppressScope = 4,
	SuppressUnwrittenScope = 5,
	SuppressInitializers = 6,
	ConstantArraySizeAsWritten = 7,
	AnonymousTagLocations = 8,
	SuppressStrongLifetime = 9,
	SuppressLifetimeQualifiers = 10,
	SuppressTemplateArgsInCXXConstructors = 11,
	Bool = 12,
	Restrict = 13,
	Alignof = 14,
	UnderscoreAlignof = 15,
	UseVoidForZeroParams = 16,
	TerseOutput = 17,
	PolishForDeclaration = 18,
	Half = 19,
	MSWChar = 20,
	IncludeNewlines = 21,
	MSVCFormatting = 22,
	ConstantsAsWritten = 23,
	SuppressImplicitBase = 24,
	FullyQualifiedName = 25,
	LastProperty = FullyQualifiedName,
}

extension Clang
{
	/** Get a property value for the given printing policy.
	 */
	[Import(Clang.dll), LinkName("clang_PrintingPolicy_getProperty")] public static extern c_uint PrintingPolicy_GetProperty(CXPrintingPolicy Policy, CXPrintingPolicyProperty Property);

	/** Set a property value for the given printing policy.
	 */
	[Import(Clang.dll), LinkName("clang_PrintingPolicy_setProperty")] public static extern void PrintingPolicy_SetProperty(CXPrintingPolicy Policy, CXPrintingPolicyProperty Property, c_uint Value);

	/** Retrieve the default policy for the cursor.
	 *  The policy should be released after use with @c clang_PrintingPolicy_dispose.  
	 */
	[Import(Clang.dll), LinkName("clang_getCursorPrintingPolicy")] public static extern CXPrintingPolicy GetCursorPrintingPolicy(CXCursor);

	/** Release a printing policy.
	 */
	[Import(Clang.dll), LinkName("clang_PrintingPolicy_dispose")] public static extern void PrintingPolicy_Dispose(CXPrintingPolicy Policy);

	/** Pretty print declarations.
	 *  
	 *  @param Cursor The cursor representing a declaration.
	 *  
	 *  @param Policy The policy to control the entities being printed. If
	 *  NULL, a default policy is used.
	 *  
	 *  @returns The pretty printed declaration or the empty string for
	 *  other cursors.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorPrettyPrinted")] public static extern CXString GetCursorPrettyPrinted(CXCursor Cursor, CXPrintingPolicy Policy);

	/** Pretty-print the underlying type using a custom printing policy.
	 *  If the type is invalid, an empty string is returned.
	 */
	[Import(Clang.dll), LinkName("clang_getTypePrettyPrinted")] public static extern CXString GetTypePrettyPrinted(CXType CT, CXPrintingPolicy cxPolicy);

	/** Get the fully qualified name for a type.
	 *  This includes full qualification of all template parameters.
	 *  Policy - Further refine the type formatting
	 *  WithGlobalNsPrefix - If non-zero, function will prepend a '::' to qualified
	 *  names
	 */
	[Import(Clang.dll), LinkName("clang_getFullyQualifiedName")] public static extern CXString GetFullyQualifiedName(CXType CT, CXPrintingPolicy Policy, c_uint WithGlobalNsPrefix);

	/** Retrieve the display name for the entity referenced by this cursor.
	 *  The display name contains extra information that helps identify the cursor,
	 *  such as the parameters of a function or template or the arguments of a
	 *  class template specialization.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorDisplayName")] public static extern CXString GetCursorDisplayName(CXCursor);

	/** For a cursor that is a reference, retrieve a cursor representing the
	 *  entity that it references.
	 *  Reference cursors refer to other entities in the AST. For example, an
	 *  Objective-C superclass reference cursor refers to an Objective-C class.
	 *  This function produces the cursor for the Objective-C class from the
	 *  cursor for the superclass reference. If the input cursor is a declaration or
	 *  definition, it returns that declaration or definition unchanged.
	 *  Otherwise, returns the NULL cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorReferenced")] public static extern CXCursor GetCursorReferenced(CXCursor);

	/** For a cursor that is either a reference to or a declaration
	 *  of some entity, retrieve a cursor that describes the definition of
	 *  that entity.
	 *  Some entities can be declared multiple times within a translation
	 *  unit, but only one of those declarations can also be a
	 *  definition. For example, given:
	 *  
	 *  ```
	 *  int f(int, int);
	 *  int g(int x, int y) { return f(x, y); }
	 *  int f(int a, int b) { return a + b; }
	 *  int f(int, int);
	 *  ```
	 *  there are three declarations of the function "f", but only the
	 *  second one is a definition. The clang_getCursorDefinition()
	 *  function will take any cursor pointing to a declaration of "f"
	 *  (the first or fourth lines of the example) or a cursor referenced
	 *  that uses "f" (the call to "f' inside "g") and will return a
	 *  declaration cursor pointing to the definition (the second "f"
	 *  declaration).
	 *  If given a cursor for which there is no corresponding definition,
	 *  e.g., because there is no definition of that entity within this
	 *  translation unit, returns a NULL cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorDefinition")] public static extern CXCursor GetCursorDefinition(CXCursor);

	/** Determine whether the declaration pointed to by this cursor
	 *  is also a definition of that entity.
	 */
	[Import(Clang.dll), LinkName("clang_isCursorDefinition")] public static extern c_uint IsCursorDefinition(CXCursor);

	/** Retrieve the canonical cursor corresponding to the given cursor.
	 *  In the C family of languages, many kinds of entities can be declared several
	 *  times within a single translation unit. For example, a structure type can
	 *  be forward-declared (possibly multiple times) and later defined:
	 *  
	 *  ```
	 *  struct X;
	 *  struct X;
	 *  struct X {
	 *  int member;
	 *  };
	 *  ```
	 *  The declarations and the definition of @c X are represented by three different cursors, all of which are declarations of the same underlying
	 *  entity. One of these cursor is considered the "canonical" cursor, which
	 *  is effectively the representative for the underlying entity. One can
	 *  determine if two cursors are declarations of the same underlying entity by
	 *  comparing their canonical cursors.
	 *  
	 *  @returns The canonical cursor for the entity referred to by the given cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getCanonicalCursor")] public static extern CXCursor GetCanonicalCursor(CXCursor);

	/** If the cursor points to a selector identifier in an Objective-C
	 *  method or message expression, this returns the selector index.
	 *  After getting a cursor with #clang_getCursor, this can be called to
	 *  determine if the location points to a selector identifier.
	 *  
	 *  @returns The selector index if the cursor is an Objective-C method or message
	 *  expression and the cursor is pointing to a selector identifier, or -1
	 *  otherwise.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getObjCSelectorIndex")] public static extern c_int Cursor_GetObjCSelectorIndex(CXCursor);

	/** Given a cursor pointing to a C++ method call or an Objective-C
	 *  message, returns non-zero if the method/message is "dynamic", meaning:
	 *  For a C++ method: the call is virtual.
	 *  For an Objective-C message: the receiver is an object instance, not 'super'
	 *  or a specific class.
	 *  If the method/message is "static" or the cursor does not point to a
	 *  method/message, it will return zero.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isDynamicCall")] public static extern c_int Cursor_IsDynamicCall(CXCursor C);

	/** Given a cursor pointing to an Objective-C message or property
	 *  reference, or C++ method call, returns the CXType of the receiver.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getReceiverType")] public static extern CXType Cursor_GetReceiverType(CXCursor C);
}

/** Property attributes for a @c CXCursor_ObjCPropertyDecl.  
 */
[CRepr, AllowDuplicates] enum CXObjCPropertyAttrKind : c_int
{
	noattr = 0x00,
	@readonly = 0x01,
	getter = 0x02,
	assign = 0x04,
	readwrite = 0x08,
	retain = 0x10,
	copy = 0x20,
	nonatomic = 0x40,
	setter = 0x80,
	atomic = 0x100,
	weak = 0x200,
	strong = 0x400,
	unsafe_unretained = 0x800,
	@class = 0x1000,
}

extension Clang
{
	/** Given a cursor that represents a property declaration, return the
	 *  associated property attributes. The bits are formed from
	 *  @c CXObjCPropertyAttrKind. 
	 *   
	 *  @param reserved Reserved for future use, pass 0.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getObjCPropertyAttributes")] public static extern c_uint Cursor_GetObjCPropertyAttributes(CXCursor C, c_uint reserved);

	/** Given a cursor that represents a property declaration, return the
	 *  name of the method that implements the getter.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getObjCPropertyGetterName")] public static extern CXString Cursor_GetObjCPropertyGetterName(CXCursor C);

	/** Given a cursor that represents a property declaration, return the
	 *  name of the method that implements the setter, if any.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getObjCPropertySetterName")] public static extern CXString Cursor_GetObjCPropertySetterName(CXCursor C);
}

/** 'Qualifiers' written next to the return and parameter types in
 *  Objective-C method declarations.
 */
[CRepr, AllowDuplicates] enum CXObjCDeclQualifierKind : c_int
{
	None = 0x0,
	In = 0x1,
	Inout = 0x2,
	Out = 0x4,
	Bycopy = 0x8,
	Byref = 0x10,
	Oneway = 0x20,
}

extension Clang
{
	/** Given a cursor that represents an Objective-C method or parameter
	 *  declaration, return the associated Objective-C qualifiers for the return
	 *  type or the parameter respectively. The bits are formed from
	 *  CXObjCDeclQualifierKind.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getObjCDeclQualifiers")] public static extern c_uint Cursor_GetObjCDeclQualifiers(CXCursor C);

	/** Given a cursor that represents an Objective-C method or property
	 *  declaration, return non-zero if the declaration was affected by "\@optional".
	 *  Returns zero if the cursor is not such a declaration or it is "\@required".
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isObjCOptional")] public static extern c_uint Cursor_IsObjCOptional(CXCursor C);

	/** Returns non-zero if the given cursor is a variadic function or method.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isVariadic")] public static extern c_uint Cursor_IsVariadic(CXCursor C);

	/** Returns non-zero if the given cursor points to a symbol marked with
	 *  external_source_symbol attribute.
	 *  
	 *  @param language If non-NULL, and the attribute is present, will be set to
	 *  the 'language' string from the attribute.
	 *  
	 *  @param definedIn If non-NULL, and the attribute is present, will be set to
	 *  the 'definedIn' string from the attribute.
	 *  
	 *  @param isGenerated If non-NULL, and the attribute is present, will be set to
	 *  non-zero if the 'generated_declaration' is set in the attribute.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isExternalSymbol")] public static extern c_uint Cursor_IsExternalSymbol(CXCursor C, CXString* language, CXString* definedIn, c_uint* isGenerated);

	/** Given a cursor that represents a declaration, return the associated
	 *  comment's source range.  The range may include multiple consecutive comments
	 *  with whitespace in between.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getCommentRange")] public static extern CXSourceRange Cursor_GetCommentRange(CXCursor C);

	/** Given a cursor that represents a declaration, return the associated
	 *  comment text, including comment markers.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getRawCommentText")] public static extern CXString Cursor_GetRawCommentText(CXCursor C);

	/** Given a cursor that represents a documentable entity (e.g.,
	 *  declaration), return the associated 
	 *  ; otherwise return the
	 *  first paragraph.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getBriefCommentText")] public static extern CXString Cursor_GetBriefCommentText(CXCursor C);

	/** Retrieve the CXString representing the mangled name of the cursor.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getMangling")] public static extern CXString Cursor_GetMangling(CXCursor);

	/** Retrieve the CXStrings representing the mangled symbols of the C++
	 *  constructor or destructor at the cursor.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getCXXManglings")] public static extern CXStringSet* Cursor_GetCXXManglings(CXCursor);

	/** Retrieve the CXStrings representing the mangled symbols of the ObjC
	 *  class interface or implementation at the cursor.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getObjCManglings")] public static extern CXStringSet* Cursor_GetObjCManglings(CXCursor);

	/** Given a CXCursor_GCCAsmStmt cursor, return the assembly template string.
	 *  As per LLVM IR Assembly Template language, template placeholders for
	 *  inputs and outputs are either of the form $N where N is a decimal number
	 *  as an index into the input-output specification,
	 *  or ${N:M} where N is a decimal number also as an index into the
	 *  input-output specification and M is the template argument modifier.
	 *  The index N in both cases points into the the total inputs and outputs,
	 *  or more specifically, into the list of outputs followed by the inputs,
	 *  starting from index 0 as the first available template argument.
	 *  This function also returns a valid empty string if the cursor does not point
	 *  at a GCC inline assembly block.
	 *  Users are responsible for releasing the allocation of returned string via
	 *  @c clang_disposeString.  
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyTemplate")] public static extern CXString Cursor_GetGCCAssemblyTemplate(CXCursor);

	/** Given a CXCursor_GCCAsmStmt cursor, check if the assembly block has goto
	 *  labels.
	 *  This function also returns 0 if the cursor does not point at a GCC inline
	 *  assembly block.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isGCCAssemblyHasGoto")] public static extern c_uint Cursor_IsGCCAssemblyHasGoto(CXCursor);

	/** Given a CXCursor_GCCAsmStmt cursor, count the number of outputs.
	 *  This function also returns 0 if the cursor does not point at a GCC inline
	 *  assembly block.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyNumOutputs")] public static extern c_uint Cursor_GetGCCAssemblyNumOutputs(CXCursor);

	/** Given a CXCursor_GCCAsmStmt cursor, count the number of inputs.
	 *  This function also returns 0 if the cursor does not point at a GCC inline
	 *  assembly block.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyNumInputs")] public static extern c_uint Cursor_GetGCCAssemblyNumInputs(CXCursor);

	/** Given a CXCursor_GCCAsmStmt cursor, get the constraint and expression cursor
	 *  to the Index-th input.
	 *  This function returns 1 when the cursor points at a GCC inline assembly
	 *  statement, `Index` is within bounds and both the `Constraint` and `Expr` are
	 *  not NULL.
	 *  Otherwise, this function returns 0 but leaves `Constraint` and `Expr`
	 *  intact.
	 *  Users are responsible for releasing the allocation of `Constraint` via
	 *  @c clang_disposeString.  
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyInput")] public static extern c_uint Cursor_GetGCCAssemblyInput(CXCursor Cursor, c_uint Index, CXString* Constraint, CXCursor* Expr);

	/** Given a CXCursor_GCCAsmStmt cursor, get the constraint and expression cursor
	 *  to the Index-th output.
	 *  This function returns 1 when the cursor points at a GCC inline assembly
	 *  statement, `Index` is within bounds and both the `Constraint` and `Expr` are
	 *  not NULL.
	 *  Otherwise, this function returns 0 but leaves `Constraint` and `Expr`
	 *  intact.
	 *  Users are responsible for releasing the allocation of `Constraint` via
	 *  @c clang_disposeString.  
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyOutput")] public static extern c_uint Cursor_GetGCCAssemblyOutput(CXCursor Cursor, c_uint Index, CXString* Constraint, CXCursor* Expr);

	/** Given a CXCursor_GCCAsmStmt cursor, count the clobbers in it.
	 *  This function also returns 0 if the cursor does not point at a GCC inline
	 *  assembly block.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyNumClobbers")] public static extern c_uint Cursor_GetGCCAssemblyNumClobbers(CXCursor Cursor);

	/** Given a CXCursor_GCCAsmStmt cursor, get the Index-th clobber of it.
	 *  This function returns a valid empty string if the cursor does not point
	 *  at a GCC inline assembly block or `Index` is out of bounds.
	 *  Users are responsible for releasing the allocation of returned string via
	 *  @c clang_disposeString.  
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getGCCAssemblyClobber")] public static extern CXString Cursor_GetGCCAssemblyClobber(CXCursor Cursor, c_uint Index);

	/** Given a CXCursor_GCCAsmStmt cursor, check if the inline assembly is
	 *  `volatile`.
	 *  This function returns 0 if the cursor does not point at a GCC inline
	 *  assembly block.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_isGCCAssemblyVolatile")] public static extern c_uint Cursor_IsGCCAssemblyVolatile(CXCursor Cursor);
}

/** 
 *   CINDEX_MODULE Module introspection
 *  The functions in this group provide access to information about modules.
 *  @{ 
 */
class CXModule { private this() {} }

extension Clang
{
	/** Given a CXCursor_ModuleImportDecl cursor, return the associated module.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_getModule")] public static extern CXModule Cursor_GetModule(CXCursor C);

	/** Given a CXFile header file, return the module that contains it, if one
	 *  exists.
	 */
	[Import(Clang.dll), LinkName("clang_getModuleForFile")] public static extern CXModule GetModuleForFile(CXTranslationUnit, CXFile);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @returns the module file where the provided module object came from.
	 */
	[Import(Clang.dll), LinkName("clang_Module_getASTFile")] public static extern CXFile Module_GetASTFile(CXModule Module);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @returns the parent of a sub-module or NULL if the given module is top-level,
	 *  e.g. for 'std.vector' it will return the 'std' module.
	 */
	[Import(Clang.dll), LinkName("clang_Module_getParent")] public static extern CXModule Module_GetParent(CXModule Module);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @returns the name of the module, e.g. for the 'std.vector' sub-module it
	 *  will return "vector".
	 */
	[Import(Clang.dll), LinkName("clang_Module_getName")] public static extern CXString Module_GetName(CXModule Module);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @returns the full name of the module, e.g. "std.vector".
	 */
	[Import(Clang.dll), LinkName("clang_Module_getFullName")] public static extern CXString Module_GetFullName(CXModule Module);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @returns non-zero if the module is a system one.
	 */
	[Import(Clang.dll), LinkName("clang_Module_isSystem")] public static extern c_int Module_IsSystem(CXModule Module);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @returns the number of top level headers associated with this module.
	 */
	[Import(Clang.dll), LinkName("clang_Module_getNumTopLevelHeaders")] public static extern c_uint Module_GetNumTopLevelHeaders(CXTranslationUnit, CXModule Module);

	/** 
	 *  @param Module a module object.
	 *  
	 *  @param Index top level header index (zero-based).
	 *  
	 *  @returns the specified top level header associated with the module.
	 */
	[Import(Clang.dll), LinkName("clang_Module_getTopLevelHeader")] public static extern CXFile Module_GetTopLevelHeader(CXTranslationUnit, CXModule Module, c_uint Index);

	/** Determine if a C++ constructor is a converting constructor.
	 */
	[Import(Clang.dll), LinkName("clang_CXXConstructor_isConvertingConstructor")] public static extern c_uint CXXConstructor_IsConvertingConstructor(CXCursor C);

	/** Determine if a C++ constructor is a copy constructor.
	 */
	[Import(Clang.dll), LinkName("clang_CXXConstructor_isCopyConstructor")] public static extern c_uint CXXConstructor_IsCopyConstructor(CXCursor C);

	/** Determine if a C++ constructor is the default constructor.
	 */
	[Import(Clang.dll), LinkName("clang_CXXConstructor_isDefaultConstructor")] public static extern c_uint CXXConstructor_IsDefaultConstructor(CXCursor C);

	/** Determine if a C++ constructor is a move constructor.
	 */
	[Import(Clang.dll), LinkName("clang_CXXConstructor_isMoveConstructor")] public static extern c_uint CXXConstructor_IsMoveConstructor(CXCursor C);

	/** Determine if a C++ field is declared 'mutable'.
	 */
	[Import(Clang.dll), LinkName("clang_CXXField_isMutable")] public static extern c_uint CXXField_IsMutable(CXCursor C);

	/** Determine if a C++ method is declared '= default'.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isDefaulted")] public static extern c_uint CXXMethod_IsDefaulted(CXCursor C);

	/** Determine if a C++ method is declared '= delete'.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isDeleted")] public static extern c_uint CXXMethod_IsDeleted(CXCursor C);

	/** Determine if a C++ member function or member function template is
	 *  pure virtual.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isPureVirtual")] public static extern c_uint CXXMethod_IsPureVirtual(CXCursor C);

	/** Determine if a C++ member function or member function template is
	 *  declared 'static'.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isStatic")] public static extern c_uint CXXMethod_IsStatic(CXCursor C);

	/** Determine if a C++ member function or member function template is
	 *  explicitly declared 'virtual' or if it overrides a virtual method from
	 *  one of the base classes.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isVirtual")] public static extern c_uint CXXMethod_IsVirtual(CXCursor C);

	/** Determine if a C++ member function is a copy-assignment operator,
	 *  returning 1 if such is the case and 0 otherwise.
	 *  > A copy-assignment operator `X::operator=` is a non-static,
	 *  > non-template member function of _class_ `X` with exactly one
	 *  > parameter of type `X`, `X
	 *  &
	 *  `, `const X
	 *  &
	 *  `, `volatile X
	 *  &
	 *  ` or `const
	 *  > volatile X
	 *  &
	 *  `.
	 *  That is, for example, the `operator=` in:
	 *  class Foo {
	 *  bool operator=(const volatile Foo
	 *  &
	 *  );
	 *  };
	 *  Is a copy-assignment operator, while the `operator=` in:
	 *  class Bar {
	 *  bool operator=(const int
	 *  &
	 *  );
	 *  };
	 *  Is not.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isCopyAssignmentOperator")] public static extern c_uint CXXMethod_IsCopyAssignmentOperator(CXCursor C);

	/** Determine if a C++ member function is a move-assignment operator,
	 *  returning 1 if such is the case and 0 otherwise.
	 *  > A move-assignment operator `X::operator=` is a non-static,
	 *  > non-template member function of _class_ `X` with exactly one
	 *  > parameter of type `X
	 *  &
	 *  &
	 *  `, `const X
	 *  &
	 *  &
	 *  `, `volatile X
	 *  &
	 *  &
	 *  ` or `const
	 *  > volatile X
	 *  &
	 *  &
	 *  `.
	 *  That is, for example, the `operator=` in:
	 *  class Foo {
	 *  bool operator=(const volatile Foo
	 *  &
	 *  &
	 *  );
	 *  };
	 *  Is a move-assignment operator, while the `operator=` in:
	 *  class Bar {
	 *  bool operator=(const int
	 *  &
	 *  &
	 *  );
	 *  };
	 *  Is not.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isMoveAssignmentOperator")] public static extern c_uint CXXMethod_IsMoveAssignmentOperator(CXCursor C);

	/** Determines if a C++ constructor or conversion function was declared
	 *  explicit, returning 1 if such is the case and 0 otherwise.
	 *  Constructors or conversion functions are declared explicit through
	 *  the use of the explicit specifier.
	 *  For example, the following constructor and conversion function are
	 *  not explicit as they lack the explicit specifier:
	 *  class Foo {
	 *  Foo();
	 *  operator int();
	 *  };
	 *  While the following constructor and conversion function are
	 *  explicit as they are declared with the explicit specifier.
	 *  class Foo {
	 *  explicit Foo();
	 *  explicit operator int();
	 *  };
	 *  This function will return 0 when given a cursor pointing to one of
	 *  the former declarations and it will return 1 for a cursor pointing
	 *  to the latter declarations.
	 *  The explicit specifier allows the user to specify a
	 *  conditional compile-time expression whose value decides
	 *  whether the marked element is explicit or not.
	 *  For example:
	 *  constexpr bool foo(int i) { return i % 2 == 0; }
	 *  class Foo {
	 *  explicit(foo(1)) Foo();
	 *  explicit(foo(2)) operator int();
	 *  }
	 *  This function will return 0 for the constructor and 1 for
	 *  the conversion function.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isExplicit")] public static extern c_uint CXXMethod_IsExplicit(CXCursor C);

	/** Determine if a C++ record is abstract, i.e. whether a class or struct
	 *  has a pure virtual member function.
	 */
	[Import(Clang.dll), LinkName("clang_CXXRecord_isAbstract")] public static extern c_uint CXXRecord_IsAbstract(CXCursor C);

	/** Determine if an enum declaration refers to a scoped enum.
	 */
	[Import(Clang.dll), LinkName("clang_EnumDecl_isScoped")] public static extern c_uint EnumDecl_IsScoped(CXCursor C);

	/** Determine if a C++ member function or member function template is
	 *  declared 'const'.
	 */
	[Import(Clang.dll), LinkName("clang_CXXMethod_isConst")] public static extern c_uint CXXMethod_IsConst(CXCursor C);

	/** Given a cursor that represents a template, determine
	 *  the cursor kind of the specializations would be generated by instantiating
	 *  the template.
	 *  This routine can be used to determine what flavor of function template,
	 *  class template, or class template partial specialization is stored in the
	 *  cursor. For example, it can describe whether a class template cursor is
	 *  declared with "struct", "class" or "union".
	 *  
	 *  @param C The cursor to query. This cursor should represent a template
	 *  declaration.
	 *  
	 *  @returns The cursor kind of the specializations that would be generated
	 *  by instantiating the template @p C. If  @p C is not a template, returns @c CXCursor_NoDeclFound.  
	 */
	[Import(Clang.dll), LinkName("clang_getTemplateCursorKind")] public static extern CXCursorKind GetTemplateCursorKind(CXCursor C);

	/** Given a cursor that may represent a specialization or instantiation
	 *  of a template, retrieve the cursor that represents the template that it
	 *  specializes or from which it was instantiated.
	 *  This routine determines the template involved both for explicit
	 *  specializations of templates and for implicit instantiations of the template,
	 *  both of which are referred to as "specializations". For a class template
	 *  specialization (e.g., @c std::vector<bool>), this routine will return either the primary template (@c std::vector) or, if the specialization was instantiated from a class template partial specialization, the class template
	 *  partial specialization. For a class template partial specialization and a
	 *  function template specialization (including instantiations), this
	 *  this routine will return the specialized template.
	 *  For members of a class template (e.g., member functions, member classes, or
	 *  static data members), returns the specialized or instantiated member.
	 *  Although not strictly "templates" in the C++ language, members of class
	 *  templates have the same notions of specializations and instantiations that
	 *  templates do, so this routine treats them similarly.
	 *  
	 *  @param C A cursor that may be a specialization of a template or a member
	 *  of a template.
	 *  
	 *  @returns If the given cursor is a specialization or instantiation of a
	 *  template or a member thereof, the template or member that it specializes or
	 *  from which it was instantiated. Otherwise, returns a NULL cursor.
	 */
	[Import(Clang.dll), LinkName("clang_getSpecializedCursorTemplate")] public static extern CXCursor GetSpecializedCursorTemplate(CXCursor C);

	/** Given a cursor that references something else, return the source range
	 *  covering that reference.
	 *  
	 *  @param C A cursor pointing to a member reference, a declaration reference, or
	 *  an operator call.
	 *  
	 *  @param NameFlags A bitset with three independent flags:
	 *  CXNameRange_WantQualifier, CXNameRange_WantTemplateArgs, and
	 *  CXNameRange_WantSinglePiece.
	 *  
	 *  @param PieceIndex For contiguous names or when passing the flag
	 *  CXNameRange_WantSinglePiece, only one piece with index 0 is
	 *  available. When the CXNameRange_WantSinglePiece flag is not passed for a
	 *  non-contiguous names, this index can be used to retrieve the individual
	 *  pieces of the name. See also CXNameRange_WantSinglePiece.
	 *  
	 *  @returns The piece of the name pointed to by the given cursor. If there is no
	 *  name, or if the PieceIndex is out-of-range, a null-cursor will be returned.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorReferenceNameRange")] public static extern CXSourceRange GetCursorReferenceNameRange(CXCursor C, c_uint NameFlags, c_uint PieceIndex);
}

[CRepr, AllowDuplicates] enum CXNameRefFlags : c_int
{
	/** Include the nested-name-specifier, e.g. Foo:: in x.Foo::y, in the
	 *  range.
	 */
	ange_WantQualifier = 0x1,

	/** Include the explicit template arguments, e.g. 
	 *  <
	 *  int> in x.f
	 *  <int
	 *  >,
	 *  in the range.
	 */
	ange_WantTemplateArgs = 0x2,

	/** If the name is non-contiguous, return the full spanning range.
	 *  Non-contiguous names occur in Objective-C when a selector with two or more
	 *  parameters is used, or in C++ when using an operator:
	 *  
	 *  ```
	 *  [object doSomething:here withValue:there]; // Objective-C
	 *  return some_vector[1]; // C++
	 *  ```
	 *  
	 */
	ange_WantSinglePiece = 0x4,
}

/** Describes a kind of token.
 */
[CRepr, AllowDuplicates] enum CXTokenKind : c_int
{
	/** A token that contains some kind of punctuation.
	 */
	Punctuation = 0,

	/** A language keyword.
	 */
	Keyword = 1,

	/** An identifier (that is not a keyword).
	 */
	Identifier = 2,

	/** A numeric, string, or character literal.
	 */
	Literal = 3,

	/** A comment.
	 */
	Comment = 4,
}

/** Describes a single preprocessing token.
 */
[CRepr] struct CXToken
{
	public c_uint[4] int_data;
	public void* ptr_data;
}

extension Clang
{
	/** Get the raw lexical token starting with the given location.
	 *  
	 *  @param TU the translation unit whose text is being tokenized.
	 *  
	 *  @param Location the source location with which the token starts.
	 *  
	 *  @returns The token starting with the given location or NULL if no such token
	 *  exist. The returned pointer must be freed with clang_disposeTokens before the
	 *  translation unit is destroyed.
	 */
	[Import(Clang.dll), LinkName("clang_getToken")] public static extern CXToken* GetToken(CXTranslationUnit TU, CXSourceLocation Location);

	/** Determine the kind of the given token.
	 */
	[Import(Clang.dll), LinkName("clang_getTokenKind")] public static extern CXTokenKind GetTokenKind(CXToken);

	/** Determine the spelling of the given token.
	 *  The spelling of a token is the textual representation of that token, e.g.,
	 *  the text of an identifier or keyword.
	 */
	[Import(Clang.dll), LinkName("clang_getTokenSpelling")] public static extern CXString GetTokenSpelling(CXTranslationUnit, CXToken);

	/** Retrieve the source location of the given token.
	 */
	[Import(Clang.dll), LinkName("clang_getTokenLocation")] public static extern CXSourceLocation GetTokenLocation(CXTranslationUnit, CXToken);

	/** Retrieve a source range that covers the given token.
	 */
	[Import(Clang.dll), LinkName("clang_getTokenExtent")] public static extern CXSourceRange GetTokenExtent(CXTranslationUnit, CXToken);

	/** Tokenize the source code described by the given range into raw
	 *  lexical tokens.
	 *  
	 *  @param TU the translation unit whose text is being tokenized.
	 *  
	 *  @param Range the source range in which text should be tokenized. All of the
	 *  tokens produced by tokenization will fall within this source range,
	 *  
	 *  @param Tokens this pointer will be set to point to the array of tokens
	 *  that occur within the given source range. The returned pointer must be
	 *  freed with clang_disposeTokens() before the translation unit is destroyed.
	 *  
	 *  @param NumTokens will be set to the number of tokens in the @c *Tokens array. 
	 *  
	 */
	[Import(Clang.dll), LinkName("clang_tokenize")] public static extern void Tokenize(CXTranslationUnit TU, CXSourceRange Range, CXToken** Tokens, c_uint* NumTokens);

	/** Annotate the given set of tokens by providing cursors for each token
	 *  that can be mapped to a specific entity within the abstract syntax tree.
	 *  This token-annotation routine is equivalent to invoking
	 *  clang_getCursor() for the source locations of each of the
	 *  tokens. The cursors provided are filtered, so that only those
	 *  cursors that have a direct correspondence to the token are
	 *  accepted. For example, given a function call @c f(x), clang_getCursor() would provide the following cursors: 
	 *  * when the cursor is over the 'f', a DeclRefExpr cursor referring to 'f'.
	 *  * when the cursor is over the '(' or the ')', a CallExpr referring to 'f'.
	 *  * when the cursor is over the 'x', a DeclRefExpr cursor referring to 'x'.
	 *  Only the first and last of these cursors will occur within the
	 *  annotate, since the tokens "f" and "x' directly refer to a function
	 *  and a variable, respectively, but the parentheses are just a small
	 *  part of the full syntax of the function call expression, which is
	 *  not provided as an annotation.
	 *  
	 *  @param TU the translation unit that owns the given tokens.
	 *  
	 *  @param Tokens the set of tokens to annotate.
	 *  
	 *  @param NumTokens the number of tokens in @p Tokens. 
	 *   
	 *  @param Cursors an array of @p NumTokens cursors, whose contents will be replaced with the cursors corresponding to each token.
	 */
	[Import(Clang.dll), LinkName("clang_annotateTokens")] public static extern void AnnotateTokens(CXTranslationUnit TU, CXToken* Tokens, c_uint NumTokens, CXCursor* Cursors);

	/** Free the given set of tokens.
	 */
	[Import(Clang.dll), LinkName("clang_disposeTokens")] public static extern void DisposeTokens(CXTranslationUnit TU, CXToken* Tokens, c_uint NumTokens);

	/** 
	 *   CINDEX_DEBUG Debugging facilities
	 *  These routines are used for testing and debugging, only, and should not
	 *  be relied upon.
	 *  @{ 
	 */
	[Import(Clang.dll), LinkName("clang_getCursorKindSpelling")] public static extern CXString GetCursorKindSpelling(CXCursorKind Kind);

	[Import(Clang.dll), LinkName("clang_getDefinitionSpellingAndExtent")] public static extern void GetDefinitionSpellingAndExtent(CXCursor, c_char** startBuf, c_char** endBuf, c_uint* startLine, c_uint* startColumn, c_uint* endLine, c_uint* endColumn);
	[Import(Clang.dll), LinkName("clang_enableStackTraces")] public static extern void EnableStackTraces();
	[Import(Clang.dll), LinkName("clang_executeOnThread")] public static extern void ExecuteOnThread(function void(void*) fn, void* user_data, c_uint stack_size);
}

/** A semantic string that describes a code-completion result.
 *  A semantic string that describes the formatting of a code-completion
 *  result as a single "template" of text that should be inserted into the
 *  source buffer when a particular code-completion result is selected.
 *  Each semantic string is made up of some number of "chunks", each of which
 *  contains some text along with a description of what that text means, e.g.,
 *  the name of the entity being referenced, whether the text chunk is part of
 *  the template, or whether it is a "placeholder" that the user should replace
 *  with actual code,of a specific kind. See @c CXCompletionChunkKind for a description of the different kinds of chunks.
 */
class CXCompletionString { private this() {} }

/** A single result of code completion.
 */
[CRepr] struct CXCompletionResult
{
	/** The kind of entity that this completion refers to.
	 *  The cursor kind will be a macro, keyword, or a declaration (one of the
	 *  *Decl cursor kinds), describing the entity that the completion is
	 *  referring to.
	 *  
	 *  @todo In the future, we would like to provide a full cursor, to allow
	 *  the client to extract additional information from declaration.
	 */
	public CXCursorKind CursorKind;

	/** The code-completion string that describes how to insert this
	 *  code-completion result into the editing buffer.
	 */
	public CXCompletionString CompletionString;
}

/** Describes a single piece of text within a code-completion string.
 *  Each "chunk" within a code-completion string (@c CXCompletionString) is either a piece of text with a specific "kind" that describes how that text
 *  should be interpreted by the client or is another completion string.
 */
[CRepr, AllowDuplicates] enum CXCompletionChunkKind : c_int
{
	/** A code-completion string that describes "optional" text that
	 *  could be a part of the template (but is not required).
	 *  The Optional chunk is the only kind of chunk that has a code-completion
	 *  string for its representation, which is accessible via
	 *  @c clang_getCompletionChunkCompletionString(). The code-completion string describes an additional part of the template that is completely optional.
	 *  For example, optional chunks can be used to describe the placeholders for
	 *  arguments that match up with defaulted function parameters, e.g. given:
	 *  
	 *  ```
	 *  void f(int x, float y = 3.14, double z = 2.71828);
	 *  ```
	 *  The code-completion string for this function would contain:
	 *  - a TypedText chunk for "f".
	 *  - a LeftParen chunk for "(".
	 *  - a Placeholder chunk for "int x"
	 *  - an Optional chunk containing the remaining defaulted arguments, e.g.,
	 *  - a Comma chunk for ","
	 *  - a Placeholder chunk for "float y"
	 *  - an Optional chunk containing the last defaulted argument:
	 *  - a Comma chunk for ","
	 *  - a Placeholder chunk for "double z"
	 *  - a RightParen chunk for ")"
	 *  There are many ways to handle Optional chunks. Two simple approaches are:
	 *  - Completely ignore optional chunks, in which case the template for the
	 *  function "f" would only include the first parameter ("int x").
	 *  - Fully expand all optional chunks, in which case the template for the
	 *  function "f" would have all of the parameters.
	 */
	Optional = 0,

	/** Text that a user would be expected to type to get this
	 *  code-completion result.
	 *  There will be exactly one "typed text" chunk in a semantic string, which
	 *  will typically provide the spelling of a keyword or the name of a
	 *  declaration that could be used at the current code point. Clients are
	 *  expected to filter the code-completion results based on the text in this
	 *  chunk.
	 */
	TypedText = 1,

	/** Text that should be inserted as part of a code-completion result.
	 *  A "text" chunk represents text that is part of the template to be
	 *  inserted into user code should this particular code-completion result
	 *  be selected.
	 */
	Text = 2,

	/** Placeholder text that should be replaced by the user.
	 *  A "placeholder" chunk marks a place where the user should insert text
	 *  into the code-completion template. For example, placeholders might mark
	 *  the function parameters for a function declaration, to indicate that the
	 *  user should provide arguments for each of those parameters. The actual
	 *  text in a placeholder is a suggestion for the text to display before
	 *  the user replaces the placeholder with real code.
	 */
	Placeholder = 3,

	/** Informative text that should be displayed but never inserted as
	 *  part of the template.
	 *  An "informative" chunk contains annotations that can be displayed to
	 *  help the user decide whether a particular code-completion result is the
	 *  right option, but which is not part of the actual template to be inserted
	 *  by code completion.
	 */
	Informative = 4,

	/** Text that describes the current parameter when code-completion is
	 *  referring to function call, message send, or template specialization.
	 *  A "current parameter" chunk occurs when code-completion is providing
	 *  information about a parameter corresponding to the argument at the
	 *  code-completion point. For example, given a function
	 *  
	 *  ```
	 *  int add(int x, int y);
	 *  ```
	 *  and the source code @c add(, where the code-completion point is after the "(", the code-completion string will contain a "current parameter" chunk
	 *  for "int x", indicating that the current argument will initialize that
	 *  parameter. After typing further, to @c add(17, (where the code-completion point is after the ","), the code-completion string will contain a
	 *  "current parameter" chunk to "int y".
	 */
	CurrentParameter = 5,

	/** A left parenthesis ('('), used to initiate a function call or
	 *  signal the beginning of a function parameter list.
	 */
	LeftParen = 6,

	/** A right parenthesis (')'), used to finish a function call or
	 *  signal the end of a function parameter list.
	 */
	RightParen = 7,

	/** A left bracket ('[').
	 */
	LeftBracket = 8,

	/** A right bracket (']').
	 */
	RightBracket = 9,

	/** A left brace ('{').
	 */
	LeftBrace = 10,

	/** A right brace ('}').
	 */
	RightBrace = 11,

	/** A left angle bracket ('
	 *  <
	 *  ').
	 */
	LeftAngle = 12,

	/** A right angle bracket ('>').
	 */
	RightAngle = 13,

	/** A comma separator (',').
	 */
	Comma = 14,

	/** Text that specifies the result type of a given result.
	 *  This special kind of informative chunk is not meant to be inserted into
	 *  the text buffer. Rather, it is meant to illustrate the type that an
	 *  expression using the given completion string would have.
	 */
	ResultType = 15,

	/** A colon (':').
	 */
	Colon = 16,

	/** A semicolon (';').
	 */
	SemiColon = 17,

	/** An '=' sign.
	 */
	Equal = 18,

	/** Horizontal space (' ').
	 */
	HorizontalSpace = 19,

	/** Vertical space ('@n'), after which it is generally a good idea to perform indentation.
	 */
	VerticalSpace = 20,
}

extension Clang
{
	/** Determine the kind of a particular chunk within a completion string.
	 *  
	 *  @param completion_string the completion string to query.
	 *  
	 *  @param chunk_number the 0-based index of the chunk in the completion string.
	 *  
	 *  @returns the kind of the chunk at the index @c chunk_number.  
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionChunkKind")] public static extern CXCompletionChunkKind GetCompletionChunkKind(CXCompletionString completion_string, c_uint chunk_number);

	/** Retrieve the text associated with a particular chunk within a
	 *  completion string.
	 *  
	 *  @param completion_string the completion string to query.
	 *  
	 *  @param chunk_number the 0-based index of the chunk in the completion string.
	 *  
	 *  @returns the text associated with the chunk at index @c chunk_number.  
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionChunkText")] public static extern CXString GetCompletionChunkText(CXCompletionString completion_string, c_uint chunk_number);

	/** Retrieve the completion string associated with a particular chunk
	 *  within a completion string.
	 *  
	 *  @param completion_string the completion string to query.
	 *  
	 *  @param chunk_number the 0-based index of the chunk in the completion string.
	 *  
	 *  @returns the completion string associated with the chunk at index
	 *  @c chunk_number.  
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionChunkCompletionString")] public static extern CXCompletionString GetCompletionChunkCompletionString(CXCompletionString completion_string, c_uint chunk_number);

	/** Retrieve the number of chunks in the given code-completion string.
	 */
	[Import(Clang.dll), LinkName("clang_getNumCompletionChunks")] public static extern c_uint GetNumCompletionChunks(CXCompletionString completion_string);

	/** Determine the priority of this code completion.
	 *  The priority of a code completion indicates how likely it is that this
	 *  particular completion is the completion that the user will select. The
	 *  priority is selected by various internal heuristics.
	 *  
	 *  @param completion_string The completion string to query.
	 *  
	 *  @returns The priority of this completion string. Smaller values indicate
	 *  higher-priority (more likely) completions.
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionPriority")] public static extern c_uint GetCompletionPriority(CXCompletionString completion_string);

	/** Determine the availability of the entity that this code-completion
	 *  string refers to.
	 *  
	 *  @param completion_string The completion string to query.
	 *  
	 *  @returns The availability of the completion string.
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionAvailability")] public static extern CXAvailabilityKind GetCompletionAvailability(CXCompletionString completion_string);

	/** Retrieve the number of annotations associated with the given
	 *  completion string.
	 *  
	 *  @param completion_string the completion string to query.
	 *  
	 *  @returns the number of annotations associated with the given completion
	 *  string.
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionNumAnnotations")] public static extern c_uint GetCompletionNumAnnotations(CXCompletionString completion_string);

	/** Retrieve the annotation associated with the given completion string.
	 *  
	 *  @param completion_string the completion string to query.
	 *  
	 *  @param annotation_number the 0-based index of the annotation of the
	 *  completion string.
	 *  
	 *  @returns annotation string associated with the completion at index
	 *  @c annotation_number, or a NULL string if that annotation is not available. 
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionAnnotation")] public static extern CXString GetCompletionAnnotation(CXCompletionString completion_string, c_uint annotation_number);

	/** Retrieve the parent context of the given completion string.
	 *  The parent context of a completion string is the semantic parent of
	 *  the declaration (if any) that the code completion represents. For example,
	 *  a code completion for an Objective-C method would have the method's class
	 *  or protocol as its context.
	 *  
	 *  @param completion_string The code completion string whose parent is
	 *  being queried.
	 *  
	 *  @param kind DEPRECATED: always set to CXCursor_NotImplemented if non-NULL.
	 *  
	 *  @returns The name of the completion parent, e.g., "NSObject" if
	 *  the completion string represents a method in the NSObject class.
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionParent")] public static extern CXString GetCompletionParent(CXCompletionString completion_string, CXCursorKind* kind);

	/** Retrieve the brief documentation comment attached to the declaration
	 *  that corresponds to the given completion string.
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionBriefComment")] public static extern CXString GetCompletionBriefComment(CXCompletionString completion_string);

	/** Retrieve a completion string for an arbitrary declaration or macro
	 *  definition cursor.
	 *  
	 *  @param cursor The cursor to query.
	 *  
	 *  @returns A non-context-sensitive completion string for declaration and macro
	 *  definition cursors, or NULL for other kinds of cursors.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorCompletionString")] public static extern CXCompletionString GetCursorCompletionString(CXCursor cursor);
}

/** Contains the results of code-completion.
 *  This data structure contains the results of code completion, as
 *  produced by @c clang_codeCompleteAt(). Its contents must be freed by @c clang_disposeCodeCompleteResults.  
 */
[CRepr] struct CXCodeCompleteResults
{
	/** The code-completion results.
	 */
	public CXCompletionResult* Results;

	/** The number of code-completion results stored in the
	 *  @c Results array. 
	 */
	public c_uint NumResults;
}

extension Clang
{
	/** Retrieve the number of fix-its for the given completion index.
	 *  Calling this makes sense only if CXCodeComplete_IncludeCompletionsWithFixIts
	 *  option was set.
	 *  
	 *  @param results The structure keeping all completion results
	 *  
	 *  @param completion_index The index of the completion
	 *  
	 *  @return The number of fix-its which must be applied before the completion at
	 *  completion_index can be applied
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionNumFixIts")] public static extern c_uint GetCompletionNumFixIts(CXCodeCompleteResults* results, c_uint completion_index);

	/** Fix-its that *must* be applied before inserting the text for the
	 *  corresponding completion.
	 *  By default, clang_codeCompleteAt() only returns completions with empty
	 *  fix-its. Extra completions with non-empty fix-its should be explicitly
	 *  requested by setting CXCodeComplete_IncludeCompletionsWithFixIts.
	 *  For the clients to be able to compute position of the cursor after applying
	 *  fix-its, the following conditions are guaranteed to hold for
	 *  replacement_range of the stored fix-its:
	 *  - Ranges in the fix-its are guaranteed to never contain the completion
	 *  point (or identifier under completion point, if any) inside them, except
	 *  at the start or at the end of the range.
	 *  - If a fix-it range starts or ends with completion point (or starts or
	 *  ends after the identifier under completion point), it will contain at
	 *  least one character. It allows to unambiguously recompute completion
	 *  point after applying the fix-it.
	 *  The intuition is that provided fix-its change code around the identifier we
	 *  complete, but are not allowed to touch the identifier itself or the
	 *  completion point. One example of completions with corrections are the ones
	 *  replacing '.' with '->' and vice versa:
	 *  std::unique_ptr
	 *  <std
	 *  ::vector
	 *  <int
	 *  >> vec_ptr;
	 *  In 'vec_ptr.^', one of the completions is 'push_back', it requires
	 *  replacing '.' with '->'.
	 *  In 'vec_ptr->^', one of the completions is 'release', it requires
	 *  replacing '->' with '.'.
	 *  
	 *  @param results The structure keeping all completion results
	 *  
	 *  @param completion_index The index of the completion
	 *  
	 *  @param fixit_index The index of the fix-it for the completion at
	 *  completion_index
	 *  
	 *  @param replacement_range The fix-it range that must be replaced before the
	 *  completion at completion_index can be applied
	 *  
	 *  @returns The fix-it string that must replace the code at replacement_range
	 *  before the completion at completion_index can be applied
	 */
	[Import(Clang.dll), LinkName("clang_getCompletionFixIt")] public static extern CXString GetCompletionFixIt(CXCodeCompleteResults* results, c_uint completion_index, c_uint fixit_index, CXSourceRange* replacement_range);
}

/** Flags that can be passed to @c clang_codeCompleteAt() to modify its behavior.
 *  The enumerators in this enumeration can be bitwise-OR'd together to
 *  provide multiple options to @c clang_codeCompleteAt().  
 */
[CRepr, AllowDuplicates] enum CXCodeComplete_Flags : c_int
{
	/** Whether to include macros within the set of code
	 *  completions returned.
	 */
	IncludeMacros = 0x01,

	/** Whether to include code patterns for language constructs
	 *  within the set of code completions, e.g., for loops.
	 */
	IncludeCodePatterns = 0x02,

	/** Whether to include brief documentation within the set of code
	 *  completions returned.
	 */
	IncludeBriefComments = 0x04,

	/** Whether to speed up completion by omitting top- or namespace-level entities
	 *  defined in the preamble. There's no guarantee any particular entity is
	 *  omitted. This may be useful if the headers are indexed externally.
	 */
	SkipPreamble = 0x08,

	/** Whether to include completions with small
	 *  fix-its, e.g. change '.' to '->' on member access, etc.
	 */
	IncludeCompletionsWithFixIts = 0x10,
}

/** Bits that represent the context under which completion is occurring.
 *  The enumerators in this enumeration may be bitwise-OR'd together if multiple
 *  contexts are occurring simultaneously.
 */
[CRepr, AllowDuplicates] enum CXCompletionContext : c_int
{
	/** The context for completions is unexposed, as only Clang results
	 *  should be included. (This is equivalent to having no context bits set.)
	 */
	Unexposed = 0,

	/** Completions for any possible type should be included in the results.
	 */
	AnyType = 1 << 0,

	/** Completions for any possible value (variables, function calls, etc.)
	 *  should be included in the results.
	 */
	AnyValue = 1 << 1,

	/** Completions for values that resolve to an Objective-C object should
	 *  be included in the results.
	 */
	ObjCObjectValue = 1 << 2,

	/** Completions for values that resolve to an Objective-C selector
	 *  should be included in the results.
	 */
	ObjCSelectorValue = 1 << 3,

	/** Completions for values that resolve to a C++ class type should be
	 *  included in the results.
	 */
	CXXClassTypeValue = 1 << 4,

	/** Completions for fields of the member being accessed using the dot
	 *  operator should be included in the results.
	 */
	DotMemberAccess = 1 << 5,

	/** Completions for fields of the member being accessed using the arrow
	 *  operator should be included in the results.
	 */
	ArrowMemberAccess = 1 << 6,

	/** Completions for properties of the Objective-C object being accessed
	 *  using the dot operator should be included in the results.
	 */
	ObjCPropertyAccess = 1 << 7,

	/** Completions for enum tags should be included in the results.
	 */
	EnumTag = 1 << 8,

	/** Completions for union tags should be included in the results.
	 */
	UnionTag = 1 << 9,

	/** Completions for struct tags should be included in the results.
	 */
	StructTag = 1 << 10,

	/** Completions for C++ class names should be included in the results.
	 */
	ClassTag = 1 << 11,

	/** Completions for C++ namespaces and namespace aliases should be
	 *  included in the results.
	 */
	Namespace = 1 << 12,

	/** Completions for C++ nested name specifiers should be included in
	 *  the results.
	 */
	NestedNameSpecifier = 1 << 13,

	/** Completions for Objective-C interfaces (classes) should be included
	 *  in the results.
	 */
	ObjCInterface = 1 << 14,

	/** Completions for Objective-C protocols should be included in
	 *  the results.
	 */
	ObjCProtocol = 1 << 15,

	/** Completions for Objective-C categories should be included in
	 *  the results.
	 */
	ObjCCategory = 1 << 16,

	/** Completions for Objective-C instance messages should be included
	 *  in the results.
	 */
	ObjCInstanceMessage = 1 << 17,

	/** Completions for Objective-C class messages should be included in
	 *  the results.
	 */
	ObjCClassMessage = 1 << 18,

	/** Completions for Objective-C selector names should be included in
	 *  the results.
	 */
	ObjCSelectorName = 1 << 19,

	/** Completions for preprocessor macro names should be included in
	 *  the results.
	 */
	MacroName = 1 << 20,

	/** Natural language completions should be included in the results.
	 */
	NaturalLanguage = 1 << 21,

	/** #include file completions should be included in the results.
	 */
	IncludedFile = 1 << 22,

	/** The current context is unknown, so set all contexts.
	 */
	Unknown = ((1 << 23) - 1),
}

extension Clang
{
	/** Returns a default set of code-completion options that can be
	 *  passed to@c clang_codeCompleteAt().  
	 */
	[Import(Clang.dll), LinkName("clang_defaultCodeCompleteOptions")] public static extern c_uint DefaultCodeCompleteOptions();

	/** Perform code completion at a given location in a translation unit.
	 *  This function performs code completion at a particular file, line, and
	 *  column within source code, providing results that suggest potential
	 *  code snippets based on the context of the completion. The basic model
	 *  for code completion is that Clang will parse a complete source file,
	 *  performing syntax checking up to the location where code-completion has
	 *  been requested. At that point, a special code-completion token is passed
	 *  to the parser, which recognizes this token and determines, based on the
	 *  current location in the C/Objective-C/C++ grammar and the state of
	 *  semantic analysis, what completions to provide. These completions are
	 *  returned via a new @c CXCodeCompleteResults structure. 
	 *  Code completion itself is meant to be triggered by the client when the
	 *  user types punctuation characters or whitespace, at which point the
	 *  code-completion location will coincide with the cursor. For example, if @c p is a pointer, code-completion might be triggered after the "-" and then after the ">" in @c p->. When the code-completion location is after the ">", the completion results will provide, e.g., the members of the struct that
	 *  "p" points to. The client is responsible for placing the cursor at the
	 *  beginning of the token currently being typed, then filtering the results
	 *  based on the contents of the token. For example, when code-completing for
	 *  the expression @c p->get, the client should provide the location just after the ">" (e.g., pointing at the "g") to this code-completion hook. Then, the
	 *  client can filter the results based on the current token text ("get"), only
	 *  showing those results that start with "get". The intent of this interface
	 *  is to separate the relatively high-latency acquisition of code-completion
	 *  results from the filtering of results on a per-character basis, which must
	 *  have a lower latency.
	 *  
	 *  @param TU The translation unit in which code-completion should
	 *  occur. The source files for this translation unit need not be
	 *  completely up-to-date (and the contents of those source files may
	 *  be overridden via @p unsaved_files). Cursors referring into the translation unit may be invalidated by this invocation.
	 *  
	 *  @param complete_filename The name of the source file where code
	 *  completion should be performed. This filename may be any file
	 *  included in the translation unit.
	 *  
	 *  @param complete_line The line at which code-completion should occur.
	 *  
	 *  @param complete_column The column at which code-completion should occur.
	 *  Note that the column should point just after the syntactic construct that
	 *  initiated code completion, and not in the middle of a lexical token.
	 *  
	 *  @param unsaved_files the Files that have not yet been saved to disk
	 *  but may be required for parsing or code completion, including the
	 *  contents of those files.  The contents and name of these files (as
	 *  specified by CXUnsavedFile) are copied when necessary, so the
	 *  client only needs to guarantee their validity until the call to
	 *  this function returns.
	 *  
	 *  @param num_unsaved_files The number of unsaved file entries in @p unsaved_files. 
	 *   
	 *  @param options Extra options that control the behavior of code
	 *  completion, expressed as a bitwise OR of the enumerators of the
	 *  CXCodeComplete_Flags enumeration. The
	 *  @c clang_defaultCodeCompleteOptions() function returns a default set of code-completion options.
	 *  
	 *  @returns If successful, a new @c CXCodeCompleteResults structure containing code-completion results, which should eventually be
	 *  freed with @c clang_disposeCodeCompleteResults(). If code completion fails, returns NULL.
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteAt")] public static extern CXCodeCompleteResults* CodeCompleteAt(CXTranslationUnit TU, c_char* complete_filename, c_uint complete_line, c_uint complete_column, CXUnsavedFile* unsaved_files, c_uint num_unsaved_files, c_uint options);

	/** Sort the code-completion results in case-insensitive alphabetical
	 *  order.
	 *  
	 *  @param Results The set of results to sort.
	 *  
	 *  @param NumResults The number of results in @p Results.  
	 */
	[Import(Clang.dll), LinkName("clang_sortCodeCompletionResults")] public static extern void SortCodeCompletionResults(CXCompletionResult* Results, c_uint NumResults);

	/** Free the given set of code-completion results.
	 */
	[Import(Clang.dll), LinkName("clang_disposeCodeCompleteResults")] public static extern void DisposeCodeCompleteResults(CXCodeCompleteResults* Results);

	/** Determine the number of diagnostics produced prior to the
	 *  location where code completion was performed.
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteGetNumDiagnostics")] public static extern c_uint CodeCompleteGetNumDiagnostics(CXCodeCompleteResults* Results);

	/** Retrieve a diagnostic associated with the given code completion.
	 *  
	 *  @param Results the code completion results to query.
	 *  
	 *  @param Index the zero-based diagnostic number to retrieve.
	 *  
	 *  @returns the requested diagnostic. This diagnostic must be freed
	 *  via a call to @c clang_disposeDiagnostic().  
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteGetDiagnostic")] public static extern CXDiagnostic CodeCompleteGetDiagnostic(CXCodeCompleteResults* Results, c_uint Index);

	/** Determines what completions are appropriate for the context
	 *  the given code completion.
	 *  
	 *  @param Results the code completion results to query
	 *  
	 *  @returns the kinds of completions that are appropriate for use
	 *  along with the given code completion results.
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteGetContexts")] public static extern c_ulonglong CodeCompleteGetContexts(CXCodeCompleteResults* Results);

	/** Returns the cursor kind for the container for the current code
	 *  completion context. The container is only guaranteed to be set for
	 *  contexts where a container exists (i.e. member accesses or Objective-C
	 *  message sends); if there is not a container, this function will return
	 *  CXCursor_InvalidCode.
	 *  
	 *  @param Results the code completion results to query
	 *  
	 *  @param IsIncomplete on return, this value will be false if Clang has complete
	 *  information about the container. If Clang does not have complete
	 *  information, this value will be true.
	 *  
	 *  @returns the container kind, or CXCursor_InvalidCode if there is not a
	 *  container
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteGetContainerKind")] public static extern CXCursorKind CodeCompleteGetContainerKind(CXCodeCompleteResults* Results, c_uint* IsIncomplete);

	/** Returns the USR for the container for the current code completion
	 *  context. If there is not a container for the current context, this
	 *  function will return the empty string.
	 *  
	 *  @param Results the code completion results to query
	 *  
	 *  @returns the USR for the container
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteGetContainerUSR")] public static extern CXString CodeCompleteGetContainerUSR(CXCodeCompleteResults* Results);

	/** Returns the currently-entered selector for an Objective-C message
	 *  send, formatted like "initWithFoo:bar:". Only guaranteed to return a
	 *  non-empty string for CXCompletionContext_ObjCInstanceMessage and
	 *  CXCompletionContext_ObjCClassMessage.
	 *  
	 *  @param Results the code completion results to query
	 *  
	 *  @returns the selector (or partial selector) that has been entered thus far
	 *  for an Objective-C message send.
	 */
	[Import(Clang.dll), LinkName("clang_codeCompleteGetObjCSelector")] public static extern CXString CodeCompleteGetObjCSelector(CXCodeCompleteResults* Results);

	/** Return a version string, suitable for showing to a user, but not
	 *  intended to be parsed (the format is not guaranteed to be stable).
	 */
	[Import(Clang.dll), LinkName("clang_getClangVersion")] public static extern CXString GetClangVersion();

	/** Enable/disable crash recovery.
	 *  
	 *  @param isEnabled Flag to indicate if crash recovery is enabled.  A non-zero
	 *  value enables crash recovery, while 0 disables it.
	 */
	[Import(Clang.dll), LinkName("clang_toggleCrashRecovery")] public static extern void ToggleCrashRecovery(c_uint isEnabled);
}

/** Visitor invoked for each file in a translation unit
 *  (used with clang_getInclusions()).
 *  This visitor function will be invoked by clang_getInclusions() for each
 *  file included (either at the top-level or by 
 *  #
 *  include directives) within
 *  a translation unit.  The first argument is the file being included, and
 *  the second and third arguments provide the inclusion stack.  The
 *  array is sorted in order of immediate inclusion.  For example,
 *  the first element refers to the location that included 'included_file'.
 */
function void CXInclusionVisitor(CXFile included_file, CXSourceLocation* inclusion_stack, c_uint include_len, CXClientData client_data);

extension Clang
{
	/** Visit the set of preprocessor inclusions in a translation unit.
	 *  The visitor function is called with the provided data for every included
	 *  file.  This does not include headers included by the PCH file (unless one
	 *  is inspecting the inclusions in the PCH file itself).
	 */
	[Import(Clang.dll), LinkName("clang_getInclusions")] public static extern void GetInclusions(CXTranslationUnit tu, CXInclusionVisitor visitor, CXClientData client_data);
}

[CRepr, AllowDuplicates] enum CXEvalResultKind : c_int
{
	Int = 1,
	Float = 2,
	ObjCStrLiteral = 3,
	StrLiteral = 4,
	CFStr = 5,
	Other = 6,
	UnExposed = 0,
}

/** Evaluation result of a cursor
 */
class CXEvalResult { private this() {} }

extension Clang
{
	/** If cursor is a statement declaration tries to evaluate the
	 *  statement and if its variable, tries to evaluate its initializer,
	 *  into its corresponding type.
	 *  If it's an expression, tries to evaluate the expression.
	 */
	[Import(Clang.dll), LinkName("clang_Cursor_Evaluate")] public static extern CXEvalResult Cursor_Evaluate(CXCursor C);

	/** Returns the kind of the evaluated result.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_getKind")] public static extern CXEvalResultKind EvalResult_GetKind(CXEvalResult E);

	/** Returns the evaluation result as integer if the
	 *  kind is Int.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_getAsInt")] public static extern c_int EvalResult_GetAsInt(CXEvalResult E);

	/** Returns the evaluation result as a long long integer if the
	 *  kind is Int. This prevents overflows that may happen if the result is
	 *  returned with clang_EvalResult_getAsInt.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_getAsLongLong")] public static extern c_longlong EvalResult_GetAsLongLong(CXEvalResult E);

	/** Returns a non-zero value if the kind is Int and the evaluation
	 *  result resulted in an unsigned integer.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_isUnsignedInt")] public static extern c_uint EvalResult_IsUnsignedInt(CXEvalResult E);

	/** Returns the evaluation result as an unsigned integer if
	 *  the kind is Int and clang_EvalResult_isUnsignedInt is non-zero.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_getAsUnsigned")] public static extern c_ulonglong EvalResult_GetAsUnsigned(CXEvalResult E);

	/** Returns the evaluation result as double if the
	 *  kind is double.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_getAsDouble")] public static extern double EvalResult_GetAsDouble(CXEvalResult E);

	/** Returns the evaluation result as a constant string if the
	 *  kind is other than Int or float. User must not free this pointer,
	 *  instead call clang_EvalResult_dispose on the CXEvalResult returned
	 *  by clang_Cursor_Evaluate.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_getAsStr")] public static extern c_char* EvalResult_GetAsStr(CXEvalResult E);

	/** Disposes the created Eval memory.
	 */
	[Import(Clang.dll), LinkName("clang_EvalResult_dispose")] public static extern void EvalResult_Dispose(CXEvalResult E);
}

/** 
 *   CINDEX_HIGH Higher level API functions
 *  @{ 
 */
[CRepr, AllowDuplicates] enum CXVisitorResult : c_int
{
	Break = 0,
	Continue = 1,
}

[CRepr] struct CXCursorAndRangeVisitor
{
	public void* context;
	public function CXVisitorResult(void*, CXCursor, CXSourceRange) visit;
}

[CRepr, AllowDuplicates] enum CXResult : c_int
{
	/** Function returned successfully.
	 */
	Success = 0,

	/** One of the parameters was invalid for the function.
	 */
	Invalid = 1,

	/** The function was terminated by a callback (e.g. it returned
	 *  CXVisit_Break)
	 */
	VisitBreak = 2,
}

extension Clang
{
	/** Find references of a declaration in a specific file.
	 *  
	 *  @param cursor pointing to a declaration or a reference of one.
	 *  
	 *  @param file to search for references.
	 *  
	 *  @param visitor callback that will receive pairs of CXCursor/CXSourceRange for
	 *  each reference found.
	 *  The CXSourceRange will point inside the file; if the reference is inside
	 *  a macro (and not a macro argument) the CXSourceRange will be invalid.
	 *  
	 *  @returns one of the CXResult enumerators.
	 */
	[Import(Clang.dll), LinkName("clang_findReferencesInFile")] public static extern CXResult FindReferencesInFile(CXCursor cursor, CXFile file, CXCursorAndRangeVisitor visitor);

	/** Find #import/#include directives in a specific file.
	 *  
	 *  @param TU translation unit containing the file to query.
	 *  
	 *  @param file to search for #import/#include directives.
	 *  
	 *  @param visitor callback that will receive pairs of CXCursor/CXSourceRange for
	 *  each directive found.
	 *  
	 *  @returns one of the CXResult enumerators.
	 */
	[Import(Clang.dll), LinkName("clang_findIncludesInFile")] public static extern CXResult FindIncludesInFile(CXTranslationUnit TU, CXFile file, CXCursorAndRangeVisitor visitor);
}

struct _CXCursorAndRangeVisitorBlock;
typealias CXCursorAndRangeVisitorBlock = _CXCursorAndRangeVisitorBlock*;

extension Clang
{
	[Import(Clang.dll), LinkName("clang_findReferencesInFileWithBlock")] public static extern CXResult FindReferencesInFileWithBlock(CXCursor, CXFile, CXCursorAndRangeVisitorBlock);
	[Import(Clang.dll), LinkName("clang_findIncludesInFileWithBlock")] public static extern CXResult FindIncludesInFileWithBlock(CXTranslationUnit, CXFile, CXCursorAndRangeVisitorBlock);
}

/** The client's data object that is associated with a CXFile.
 */
class CXIdxClientFile { private this() {} }

/** The client's data object that is associated with a semantic entity.
 */
class CXIdxClientEntity { private this() {} }

/** The client's data object that is associated with a semantic container
 *  of entities.
 */
class CXIdxClientContainer { private this() {} }

/** The client's data object that is associated with an AST file (PCH
 *  or module).
 */
class CXIdxClientASTFile { private this() {} }

/** Source location passed to index callbacks.
 */
[CRepr] struct CXIdxLoc
{
	public void*[2] ptr_data;
	public c_uint int_data;
}

/** Data for ppIncludedFile callback.
 */
[CRepr] struct CXIdxIncludedFileInfo
{
	/** Location of '#' in the 
	 *  #
	 *  include/
	 *  #
	 *  import directive.
	 */
	public CXIdxLoc hashLoc;

	/** Filename as written in the 
	 *  #
	 *  include/
	 *  #
	 *  import directive.
	 */
	public c_char* filename;

	/** The actual file that the 
	 *  #
	 *  include/
	 *  #
	 *  import directive resolved to.
	 */
	public CXFile file;

	public c_int isImport;
	public c_int isAngled;

	/** Non-zero if the directive was automatically turned into a module
	 *  import.
	 */
	public c_int isModuleImport;
}

/** Data for IndexerCallbacks#importedASTFile.
 */
[CRepr] struct CXIdxImportedASTFileInfo
{
	/** Top level AST file containing the imported PCH, module or submodule.
	 */
	public CXFile file;

	/** The imported module or NULL if the AST file is a PCH.
	 */
	public CXModule module;

	/** Location where the file is imported. Applicable only for modules.
	 */
	public CXIdxLoc loc;

	/** Non-zero if an inclusion directive was automatically turned into
	 *  a module import. Applicable only for modules.
	 */
	public c_int isImplicit;
}

[CRepr, AllowDuplicates] enum CXIdxEntityKind : c_int
{
	Unexposed = 0,
	Typedef = 1,
	Function = 2,
	Variable = 3,
	Field = 4,
	EnumConstant = 5,
	ObjCClass = 6,
	ObjCProtocol = 7,
	ObjCCategory = 8,
	ObjCInstanceMethod = 9,
	ObjCClassMethod = 10,
	ObjCProperty = 11,
	ObjCIvar = 12,
	Enum = 13,
	Struct = 14,
	Union = 15,
	CXXClass = 16,
	CXXNamespace = 17,
	CXXNamespaceAlias = 18,
	CXXStaticVariable = 19,
	CXXStaticMethod = 20,
	CXXInstanceMethod = 21,
	CXXConstructor = 22,
	CXXDestructor = 23,
	CXXConversionFunction = 24,
	CXXTypeAlias = 25,
	CXXInterface = 26,
	CXXConcept = 27,
}

[CRepr, AllowDuplicates] enum CXIdxEntityLanguage : c_int
{
	None = 0,
	C = 1,
	ObjC = 2,
	CXX = 3,
	Swift = 4,
}

/** Extra C++ template information for an entity. This can apply to:
 *  CXIdxEntity_Function
 *  CXIdxEntity_CXXClass
 *  CXIdxEntity_CXXStaticMethod
 *  CXIdxEntity_CXXInstanceMethod
 *  CXIdxEntity_CXXConstructor
 *  CXIdxEntity_CXXConversionFunction
 *  CXIdxEntity_CXXTypeAlias
 */
[CRepr, AllowDuplicates] enum CXIdxEntityCXXTemplateKind : c_int
{
	NonTemplate = 0,
	Template = 1,
	TemplatePartialSpecialization = 2,
	TemplateSpecialization = 3,
}

[CRepr, AllowDuplicates] enum CXIdxAttrKind : c_int
{
	Unexposed = 0,
	IBAction = 1,
	IBOutlet = 2,
	IBOutletCollection = 3,
}

[CRepr] struct CXIdxAttrInfo
{
	public CXIdxAttrKind kind;
	public CXCursor cursor;
	public CXIdxLoc loc;
}

[CRepr] struct CXIdxEntityInfo
{
	public CXIdxEntityKind kind;
	public CXIdxEntityCXXTemplateKind templateKind;
	public CXIdxEntityLanguage lang;
	public c_char* name;
	public c_char* USR;
	public CXCursor cursor;
	public CXIdxAttrInfo** attributes;
	public c_uint numAttributes;
}

[CRepr] struct CXIdxContainerInfo
{
	public CXCursor cursor;
}

[CRepr] struct CXIdxIBOutletCollectionAttrInfo
{
	public CXIdxAttrInfo* attrInfo;
	public CXIdxEntityInfo* objcClass;
	public CXCursor classCursor;
	public CXIdxLoc classLoc;
}

[CRepr, AllowDuplicates] enum CXIdxDeclInfoFlags : c_int
{
	Flag_Skipped = 0x1,
}

[CRepr] struct CXIdxDeclInfo
{
	public CXIdxEntityInfo* entityInfo;
	public CXCursor cursor;
	public CXIdxLoc loc;
	public CXIdxContainerInfo* semanticContainer;

	/** Generally same as #semanticContainer but can be different in
	 *  cases like out-of-line C++ member functions.
	 */
	public CXIdxContainerInfo* lexicalContainer;

	public c_int isRedeclaration;
	public c_int isDefinition;
	public c_int isContainer;
	public CXIdxContainerInfo* declAsContainer;

	/** Whether the declaration exists in code or was created implicitly
	 *  by the compiler, e.g. implicit Objective-C methods for properties.
	 */
	public c_int isImplicit;

	public CXIdxAttrInfo** attributes;
	public c_uint numAttributes;
	public c_uint flags;
}

[CRepr, AllowDuplicates] enum CXIdxObjCContainerKind : c_int
{
	ForwardRef = 0,
	Interface = 1,
	Implementation = 2,
}

[CRepr] struct CXIdxObjCContainerDeclInfo
{
	public CXIdxDeclInfo* declInfo;
	public CXIdxObjCContainerKind kind;
}

[CRepr] struct CXIdxBaseClassInfo
{
	public CXIdxEntityInfo* @base;
	public CXCursor cursor;
	public CXIdxLoc loc;
}

[CRepr] struct CXIdxObjCProtocolRefInfo
{
	public CXIdxEntityInfo* protocol;
	public CXCursor cursor;
	public CXIdxLoc loc;
}

[CRepr] struct CXIdxObjCProtocolRefListInfo
{
	public CXIdxObjCProtocolRefInfo** protocols;
	public c_uint numProtocols;
}

[CRepr] struct CXIdxObjCInterfaceDeclInfo
{
	public CXIdxObjCContainerDeclInfo* containerInfo;
	public CXIdxBaseClassInfo* superInfo;
	public CXIdxObjCProtocolRefListInfo* protocols;
}

[CRepr] struct CXIdxObjCCategoryDeclInfo
{
	public CXIdxObjCContainerDeclInfo* containerInfo;
	public CXIdxEntityInfo* objcClass;
	public CXCursor classCursor;
	public CXIdxLoc classLoc;
	public CXIdxObjCProtocolRefListInfo* protocols;
}

[CRepr] struct CXIdxObjCPropertyDeclInfo
{
	public CXIdxDeclInfo* declInfo;
	public CXIdxEntityInfo* getter;
	public CXIdxEntityInfo* setter;
}

[CRepr] struct CXIdxCXXClassDeclInfo
{
	public CXIdxDeclInfo* declInfo;
	public CXIdxBaseClassInfo** bases;
	public c_uint numBases;
}

/** Data for IndexerCallbacks#indexEntityReference.
 *  This may be deprecated in a future version as this duplicates
 *  the @c CXSymbolRole_Implicit bit in  @c CXSymbolRole.  
 */
[CRepr, AllowDuplicates] enum CXIdxEntityRefKind : c_int
{
	/** The entity is referenced directly in user's code.
	 */
	Direct = 1,

	/** An implicit reference, e.g. a reference of an Objective-C method
	 *  via the dot syntax.
	 */
	Implicit = 2,
}

/** Roles that are attributed to symbol occurrences.
 *  Internal: this currently mirrors low 9 bits of clang::index::SymbolRole with
 *  higher bits zeroed. These high bits may be exposed in the future.
 */
[CRepr, AllowDuplicates] enum CXSymbolRole : c_int
{
	None = 0,
	Declaration = 1 << 0,
	Definition = 1 << 1,
	Reference = 1 << 2,
	Read = 1 << 3,
	Write = 1 << 4,
	Call = 1 << 5,
	Dynamic = 1 << 6,
	AddressOf = 1 << 7,
	Implicit = 1 << 8,
}

/** Data for IndexerCallbacks#indexEntityReference.
 */
[CRepr] struct CXIdxEntityRefInfo
{
	public CXIdxEntityRefKind kind;

	/** Reference cursor.
	 */
	public CXCursor cursor;

	public CXIdxLoc loc;

	/** The entity that gets referenced.
	 */
	public CXIdxEntityInfo* referencedEntity;

	/** Immediate "parent" of the reference. For example:
	 *  
	 *  ```
	 *  Foo *var;
	 *  ```
	 *  The parent of reference of type 'Foo' is the variable 'var'.
	 *  For references inside statement bodies of functions/methods,
	 *  the parentEntity will be the function/method.
	 */
	public CXIdxEntityInfo* parentEntity;

	/** Lexical container context of the reference.
	 */
	public CXIdxContainerInfo* container;

	/** Sets of symbol roles of the reference.
	 */
	public CXSymbolRole role;
}

/** A group of callbacks used by #clang_indexSourceFile and
 *  #clang_indexTranslationUnit.
 */
[CRepr] struct IndexerCallbacks
{
	/** Called periodically to check whether indexing should be aborted.
	 *  Should return 0 to continue, and non-zero to abort.
	 */
	public function c_int(CXClientData, void*) abortQuery;

	/** Called at the end of indexing; passes the complete diagnostic set.
	 */
	public function void(CXClientData, CXDiagnosticSet, void*) diagnostic;

	public function CXIdxClientFile(CXClientData, CXFile, void*) enteredMainFile;

	/** Called when a file gets 
	 *  #
	 *  included/
	 *  #
	 *  imported.
	 */
	public function CXIdxClientFile(CXClientData, CXIdxIncludedFileInfo*) ppIncludedFile;

	/** Called when a AST file (PCH or module) gets imported.
	 *  AST files will not get indexed (there will not be callbacks to index all
	 *  the entities in an AST file). The recommended action is that, if the AST
	 *  file is not already indexed, to initiate a new indexing job specific to
	 *  the AST file.
	 */
	public function CXIdxClientASTFile(CXClientData, CXIdxImportedASTFileInfo*) importedASTFile;

	/** Called at the beginning of indexing a translation unit.
	 */
	public function CXIdxClientContainer(CXClientData, void*) startedTranslationUnit;

	public function void(CXClientData, CXIdxDeclInfo*) indexDeclaration;

	/** Called to index a reference of an entity.
	 */
	public function void(CXClientData, CXIdxEntityRefInfo*) indexEntityReference;
}

extension Clang
{
	[Import(Clang.dll), LinkName("clang_index_isEntityObjCContainerKind")] public static extern c_int Index_IsEntityObjCContainerKind(CXIdxEntityKind);
	[Import(Clang.dll), LinkName("clang_index_getObjCContainerDeclInfo")] public static extern CXIdxObjCContainerDeclInfo* Index_GetObjCContainerDeclInfo(CXIdxDeclInfo*);
	[Import(Clang.dll), LinkName("clang_index_getObjCInterfaceDeclInfo")] public static extern CXIdxObjCInterfaceDeclInfo* Index_GetObjCInterfaceDeclInfo(CXIdxDeclInfo*);
	[Import(Clang.dll), LinkName("clang_index_getObjCCategoryDeclInfo")] public static extern CXIdxObjCCategoryDeclInfo* Index_GetObjCCategoryDeclInfo(CXIdxDeclInfo*);
	[Import(Clang.dll), LinkName("clang_index_getObjCProtocolRefListInfo")] public static extern CXIdxObjCProtocolRefListInfo* Index_GetObjCProtocolRefListInfo(CXIdxDeclInfo*);
	[Import(Clang.dll), LinkName("clang_index_getObjCPropertyDeclInfo")] public static extern CXIdxObjCPropertyDeclInfo* Index_GetObjCPropertyDeclInfo(CXIdxDeclInfo*);
	[Import(Clang.dll), LinkName("clang_index_getIBOutletCollectionAttrInfo")] public static extern CXIdxIBOutletCollectionAttrInfo* Index_GetIBOutletCollectionAttrInfo(CXIdxAttrInfo*);
	[Import(Clang.dll), LinkName("clang_index_getCXXClassDeclInfo")] public static extern CXIdxCXXClassDeclInfo* Index_GetCXXClassDeclInfo(CXIdxDeclInfo*);

	/** For retrieving a custom CXIdxClientContainer attached to a
	 *  container.
	 */
	[Import(Clang.dll), LinkName("clang_index_getClientContainer")] public static extern CXIdxClientContainer Index_GetClientContainer(CXIdxContainerInfo*);

	/** For setting a custom CXIdxClientContainer attached to a
	 *  container.
	 */
	[Import(Clang.dll), LinkName("clang_index_setClientContainer")] public static extern void Index_SetClientContainer(CXIdxContainerInfo*, CXIdxClientContainer);

	/** For retrieving a custom CXIdxClientEntity attached to an entity.
	 */
	[Import(Clang.dll), LinkName("clang_index_getClientEntity")] public static extern CXIdxClientEntity Index_GetClientEntity(CXIdxEntityInfo*);

	/** For setting a custom CXIdxClientEntity attached to an entity.
	 */
	[Import(Clang.dll), LinkName("clang_index_setClientEntity")] public static extern void Index_SetClientEntity(CXIdxEntityInfo*, CXIdxClientEntity);
}

/** An indexing action/session, to be applied to one or multiple
 *  translation units.
 */
class CXIndexAction { private this() {} }

extension Clang
{
	/** An indexing action/session, to be applied to one or multiple
	 *  translation units.
	 *  
	 *  @param CIdx The index object with which the index action will be associated.
	 */
	[Import(Clang.dll), LinkName("clang_IndexAction_create")] public static extern CXIndexAction IndexAction_Create(CXIndex CIdx);

	/** Destroy the given index action.
	 *  The index action must not be destroyed until all of the translation units
	 *  created within that index action have been destroyed.
	 */
	[Import(Clang.dll), LinkName("clang_IndexAction_dispose")] public static extern void IndexAction_Dispose(CXIndexAction);
}

[CRepr, AllowDuplicates] enum CXIndexOptFlags : c_int
{
	/** Used to indicate that no special indexing options are needed.
	 */
	None = 0x0,

	/** Used to indicate that IndexerCallbacks#indexEntityReference should
	 *  be invoked for only one reference of an entity per source file that does
	 *  not also include a declaration/definition of the entity.
	 */
	SuppressRedundantRefs = 0x1,

	/** Function-local symbols should be indexed. If this is not set
	 *  function-local symbols will be ignored.
	 */
	IndexFunctionLocalSymbols = 0x2,

	/** Implicit function/class template instantiations should be indexed.
	 *  If this is not set, implicit instantiations will be ignored.
	 */
	IndexImplicitTemplateInstantiations = 0x4,

	/** Suppress all compiler warnings when parsing for indexing.
	 */
	SuppressWarnings = 0x8,

	/** Skip a function/method body that was already parsed during an
	 *  indexing session associated with a @c CXIndexAction object. Bodies in system headers are always skipped.
	 */
	SkipParsedBodiesInSession = 0x10,
}

extension Clang
{
	/** Index the given source file and the translation unit corresponding
	 *  to that file via callbacks implemented through #IndexerCallbacks.
	 *  
	 *  @param client_data pointer data supplied by the client, which will
	 *  be passed to the invoked callbacks.
	 *  
	 *  @param index_callbacks Pointer to indexing callbacks that the client
	 *  implements.
	 *  
	 *  @param index_callbacks_size Size of #IndexerCallbacks structure that gets
	 *  passed in index_callbacks.
	 *  
	 *  @param index_options A bitmask of options that affects how indexing is
	 *  performed. This should be a bitwise OR of the CXIndexOpt_XXX flags.
	 *  
	 *  @param out_TU pointer to store a @c CXTranslationUnit that can be reused after indexing is finished. Set to @c NULL if you do not require it. 
	 *  
	 *  @returns 0 on success or if there were errors from which the compiler could
	 *  recover.  If there is a failure from which there is no recovery, returns
	 *  a non-zero @c CXErrorCode. 
	 *  The rest of the parameters are the same as #clang_parseTranslationUnit. 
	 */
	[Import(Clang.dll), LinkName("clang_indexSourceFile")] public static extern c_int IndexSourceFile(CXIndexAction, CXClientData client_data, IndexerCallbacks* index_callbacks, c_uint index_callbacks_size, c_uint index_options, c_char* source_filename, c_char** command_line_args, c_int num_command_line_args, CXUnsavedFile* unsaved_files, c_uint num_unsaved_files, out CXTranslationUnit out_TU, c_uint TU_options);

	/** Same as clang_indexSourceFile but requires a full command line
	 *  for @c command_line_args including argv[0]. This is useful if the standard library paths are relative to the binary.
	 */
	[Import(Clang.dll), LinkName("clang_indexSourceFileFullArgv")] public static extern c_int IndexSourceFileFullArgv(CXIndexAction, CXClientData client_data, IndexerCallbacks* index_callbacks, c_uint index_callbacks_size, c_uint index_options, c_char* source_filename, c_char** command_line_args, c_int num_command_line_args, CXUnsavedFile* unsaved_files, c_uint num_unsaved_files, CXTranslationUnit* out_TU, c_uint TU_options);

	/** Index the given translation unit via callbacks implemented through
	 *  #IndexerCallbacks.
	 *  The order of callback invocations is not guaranteed to be the same as
	 *  when indexing a source file. The high level order will be:
	 *  -Preprocessor callbacks invocations
	 *  -Declaration/reference callbacks invocations
	 *  -Diagnostic callback invocations
	 *  The parameters are the same as #clang_indexSourceFile.
	 *  
	 *  @returns If there is a failure from which there is no recovery, returns
	 *  non-zero, otherwise returns 0.
	 */
	[Import(Clang.dll), LinkName("clang_indexTranslationUnit")] public static extern c_int IndexTranslationUnit(CXIndexAction, CXClientData client_data, IndexerCallbacks* index_callbacks, c_uint index_callbacks_size, c_uint index_options, CXTranslationUnit);

	/** Retrieve the CXIdxFile, file, line, column, and offset represented by
	 *  the given CXIdxLoc.
	 *  If the location refers into a macro expansion, retrieves the
	 *  location of the macro expansion and if it refers into a macro argument
	 *  retrieves the location of the argument.
	 */
	[Import(Clang.dll), LinkName("clang_indexLoc_getFileLocation")] public static extern void IndexLoc_GetFileLocation(CXIdxLoc loc, CXIdxClientFile* indexFile, CXFile* file, c_uint* line, c_uint* column, c_uint* offset);

	/** Retrieve the CXSourceLocation represented by the given CXIdxLoc.
	 */
	[Import(Clang.dll), LinkName("clang_indexLoc_getCXSourceLocation")] public static extern CXSourceLocation IndexLoc_GetCXSourceLocation(CXIdxLoc loc);
}

/** Visitor invoked for each field found by a traversal.
 *  This visitor function will be invoked for each field found by
 *  @c clang_Type_visitFields. Its first argument is the cursor being visited, its second argument is the client data provided to
 *  @c clang_Type_visitFields. 
 *  The visitor should return one of the  @c CXVisitorResult values to direct @c clang_Type_visitFields.  
 */
function CXVisitorResult CXFieldVisitor(CXCursor C, CXClientData client_data);

extension Clang
{
	/** Visit the fields of a particular type.
	 *  This function visits all the direct fields of the given cursor,
	 *  invoking the given @p visitor function with the cursors of each visited field. The traversal may be ended prematurely, if
	 *  the visitor returns @c CXFieldVisit_Break. 
	 *   
	 *  @param T the record type whose field may be visited.
	 *  
	 *  @param visitor the visitor function that will be invoked for each
	 *  field of @p T. 
	 *   
	 *  @param client_data pointer data supplied by the client, which will
	 *  be passed to the visitor each time it is invoked.
	 *  
	 *  @returns a non-zero value if the traversal was terminated
	 *  prematurely by the visitor returning @c CXFieldVisit_Break.  
	 */
	[Import(Clang.dll), LinkName("clang_Type_visitFields")] public static extern c_uint Type_VisitFields(CXType T, CXFieldVisitor visitor, CXClientData client_data);

	/** Visit the base classes of a type.
	 *  This function visits all the direct base classes of a the given cursor,
	 *  invoking the given @p visitor function with the cursors of each visited base. The traversal may be ended prematurely, if
	 *  the visitor returns @c CXFieldVisit_Break. 
	 *   
	 *  @param T the record type whose field may be visited.
	 *  
	 *  @param visitor the visitor function that will be invoked for each
	 *  field of @p T. 
	 *   
	 *  @param client_data pointer data supplied by the client, which will
	 *  be passed to the visitor each time it is invoked.
	 *  
	 *  @returns a non-zero value if the traversal was terminated
	 *  prematurely by the visitor returning @c CXFieldVisit_Break.  
	 */
	[Import(Clang.dll), LinkName("clang_visitCXXBaseClasses")] public static extern c_uint VisitCXXBaseClasses(CXType T, CXFieldVisitor visitor, CXClientData client_data);

	/** Visit the class methods of a type.
	 *  This function visits all the methods of the given cursor,
	 *  invoking the given @p visitor function with the cursors of each visited method. The traversal may be ended prematurely, if
	 *  the visitor returns @c CXFieldVisit_Break. 
	 *   
	 *  @param T The record type whose field may be visited.
	 *  
	 *  @param visitor The visitor function that will be invoked for each
	 *  field of @p T. 
	 *   
	 *  @param client_data Pointer data supplied by the client, which will
	 *  be passed to the visitor each time it is invoked.
	 *  
	 *  @returns A non-zero value if the traversal was terminated
	 *  prematurely by the visitor returning @c CXFieldVisit_Break.  
	 */
	[Import(Clang.dll), LinkName("clang_visitCXXMethods")] public static extern c_uint VisitCXXMethods(CXType T, CXFieldVisitor visitor, CXClientData client_data);
}

/** Describes the kind of binary operators.
 */
[CRepr, AllowDuplicates] enum CXBinaryOperatorKind : c_int
{
	/** This value describes cursors which are not binary operators. 
	 */
	Invalid = 0,

	/** C++ Pointer - to - member operator. 
	 */
	PtrMemD = 1,

	/** C++ Pointer - to - member operator. 
	 */
	PtrMemI = 2,

	/** Multiplication operator. 
	 */
	Mul = 3,

	/** Division operator. 
	 */
	Div = 4,

	/** Remainder operator. 
	 */
	Rem = 5,

	/** Addition operator. 
	 */
	Add = 6,

	/** Subtraction operator. 
	 */
	Sub = 7,

	/** Bitwise shift left operator. 
	 */
	Shl = 8,

	/** Bitwise shift right operator. 
	 */
	Shr = 9,

	/** C++ three-way comparison (spaceship) operator. 
	 */
	Cmp = 10,

	/** Less than operator. 
	 */
	LT = 11,

	/** Greater than operator. 
	 */
	GT = 12,

	/** Less or equal operator. 
	 */
	LE = 13,

	/** Greater or equal operator. 
	 */
	GE = 14,

	/** Equal operator. 
	 */
	EQ = 15,

	/** Not equal operator. 
	 */
	NE = 16,

	/** Bitwise AND operator. 
	 */
	And = 17,

	/** Bitwise XOR operator. 
	 */
	Xor = 18,

	/** Bitwise OR operator. 
	 */
	Or = 19,

	/** Logical AND operator. 
	 */
	LAnd = 20,

	/** Logical OR operator. 
	 */
	LOr = 21,

	/** Assignment operator. 
	 */
	Assign = 22,

	/** Multiplication assignment operator. 
	 */
	MulAssign = 23,

	/** Division assignment operator. 
	 */
	DivAssign = 24,

	/** Remainder assignment operator. 
	 */
	RemAssign = 25,

	/** Addition assignment operator. 
	 */
	AddAssign = 26,

	/** Subtraction assignment operator. 
	 */
	SubAssign = 27,

	/** Bitwise shift left assignment operator. 
	 */
	ShlAssign = 28,

	/** Bitwise shift right assignment operator. 
	 */
	ShrAssign = 29,

	/** Bitwise AND assignment operator. 
	 */
	AndAssign = 30,

	/** Bitwise XOR assignment operator. 
	 */
	XorAssign = 31,

	/** Bitwise OR assignment operator. 
	 */
	OrAssign = 32,

	/** Comma operator. 
	 */
	Comma = 33,

	/** Comma operator. 
	 */
	Last = Comma,
}

extension Clang
{
	/** Retrieve the spelling of a given CXBinaryOperatorKind.
	 */
	[Import(Clang.dll), LinkName("clang_getBinaryOperatorKindSpelling")] public static extern CXString GetBinaryOperatorKindSpelling(CXBinaryOperatorKind kind);

	/** Retrieve the binary operator kind of this cursor.
	 *  If this cursor is not a binary operator then returns Invalid.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorBinaryOperatorKind")] public static extern CXBinaryOperatorKind GetCursorBinaryOperatorKind(CXCursor cursor);
}

/** Describes the kind of unary operators.
 */
[CRepr, AllowDuplicates] enum CXUnaryOperatorKind : c_int
{
	/** This value describes cursors which are not unary operators. 
	 */
	Invalid = 0,

	/** Postfix increment operator. 
	 */
	PostInc = 1,

	/** Postfix decrement operator. 
	 */
	PostDec = 2,

	/** Prefix increment operator. 
	 */
	PreInc = 3,

	/** Prefix decrement operator. 
	 */
	PreDec = 4,

	/** Address of operator. 
	 */
	AddrOf = 5,

	/** Dereference operator. 
	 */
	Deref = 6,

	/** Plus operator. 
	 */
	Plus = 7,

	/** Minus operator. 
	 */
	Minus = 8,

	/** Not operator. 
	 */
	Not = 9,

	/** LNot operator. 
	 */
	LNot = 10,

	/** "__real expr" operator. 
	 */
	Real = 11,

	/** "__imag expr" operator. 
	 */
	Imag = 12,

	/** __extension__ marker operator. 
	 */
	Extension = 13,

	/** C++ co_await operator. 
	 */
	Coawait = 14,
}

extension Clang
{
	/** Retrieve the spelling of a given CXUnaryOperatorKind.
	 */
	[Import(Clang.dll), LinkName("clang_getUnaryOperatorKindSpelling")] public static extern CXString GetUnaryOperatorKindSpelling(CXUnaryOperatorKind kind);

	/** Retrieve the unary operator kind of this cursor.
	 *  If this cursor is not a unary operator then returns Invalid.
	 */
	[Import(Clang.dll), LinkName("clang_getCursorUnaryOperatorKind")] public static extern CXUnaryOperatorKind GetCursorUnaryOperatorKind(CXCursor cursor);
}

/** @} 
 */
class CXRemapping { private this() {} }

extension Clang
{
	[Import(Clang.dll), LinkName("clang_getRemappings")] public static extern CXRemapping GetRemappings(c_char*);
	[Import(Clang.dll), LinkName("clang_getRemappingsFromFileList")] public static extern CXRemapping GetRemappingsFromFileList(c_char**, c_uint);
	[Import(Clang.dll), LinkName("clang_remap_getNumFiles")] public static extern c_uint Remap_GetNumFiles(CXRemapping);
	[Import(Clang.dll), LinkName("clang_remap_getFilenames")] public static extern void Remap_GetFilenames(CXRemapping, c_uint, CXString*, CXString*);
	[Import(Clang.dll), LinkName("clang_remap_dispose")] public static extern void Remap_Dispose(CXRemapping);
}
